<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
<title>Kotlin基础：泛型、注解、DSL</title>
<meta name="description"
      content=""
>

  
    
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-JLJBQBW5WM"></script>
    <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-JLJBQBW5WM');
  </script>
  




<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<link
  rel="alternate"
  type="application/rss+xml"
  href="https://chinalhr.github.io/index.xml"
  title="ChinaLHR Blog"
/>
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Kotlin基础：泛型、注解、DSL"/>
<meta name="twitter:description" content="
Kotlin学习记录
"/>



<link rel="stylesheet" href="https://chinalhr.github.io/fontawesome/css/all.min.css" />




<link
  crossorigin="anonymous"
  href="/css/styles.min.css"
  integrity=""
  rel="preload stylesheet"
  as="style"
/>




<link
  id="dark-mode-theme"
  crossorigin="anonymous"
  href="/css/dark.min.css"
  integrity=""
  rel="preload stylesheet"
  as="style"
/>


<script>
  var darkTheme = document.getElementById('dark-mode-theme')
  var storedTheme = localStorage.getItem('dark-mode-storage')

  if (storedTheme === 'dark') {
    darkTheme.disabled = false
  } else if (storedTheme === 'light') {
    darkTheme.disabled = true
  }
</script>


<script defer crossorigin="anonymous" src="/js/theme.js" integrity=""></script>


<script defer crossorigin="anonymous" src="/js/instantpage.min.js" integrity=""></script><meta name="generator" content="Hugo 0.68.3" />
  </head>
  <body>
    
  




  <header>
    <nav class="navbar">
  <div class="nav">
    
      <a href="https://chinalhr.github.io/" class="nav-logo">
        <img
          src="https://chinalhr.github.io/images/icon.png"
          width="50"
          height="50"
          alt="Logo"
        />
      </a>
    

    <ul class="nav-links">
      
        
          <li>
            <a href="/about/" id="About"
              ><em class="fas fa-user fa-lg"></em
            ></a>
          </li>
          
      
        
          <li>
            <a href="/categories/" id="Categories"
              ><em class="fas fa-filter fa-lg"></em
            ></a>
          </li>
          
      
        
          <li>
            <a href="/tags/" id="Tags"
              ><em class="fas fa-tags fa-lg"></em
            ></a>
          </li>
          
      
        
          <li>
            <a href="/archives/" id="Archives"
              ><em class="fas fa-archive fa-lg"></em
            ></a>
          </li>
          
      
        
          <li>
            <a href="/search/" id="Search"
              ><em class="fas fa-search fa-lg"></em
            ></a>
          </li>
          
      
    </ul>
  </div>
</nav>

    <div class="intro-header">
      <div class="container">
        <div class="post-heading">
          
            <h1>
              Kotlin基础：泛型、注解、DSL
            </h1>
          
          
            <span class="meta-post">
  <em class="fa fa-calendar-alt"></em
  >&nbsp;Mar 14, 2019
  
    &nbsp;&nbsp;&nbsp;<em class="fa fa-folder-open"></em>&nbsp;
    
      <a
        href="https://chinalhr.github.io/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"
        >后端开发</a
      >&nbsp;
    
  
</span>

          
        </div>
      </div>
    </div>
  </header>
  

    
  <div class="container" role="main">
    <article class="article" class="blog-post">
      <blockquote>
<p>Kotlin学习记录</p>
</blockquote>
<h3 id="泛型">泛型</h3>
<ul>
<li>对比Java</li>
</ul>
<p>和 Java 不同， Kotlin 始终要求类型实参要么被显式地说明，要么能被编译器推导出来。(因为Java有历史包袱,1.5才引入泛型)</p>
<ul>
<li>泛型类型约束</li>
</ul>
<p>约束上界 : &lt; T : Number&gt; T sum(List &lt; T&gt; list)</p>
<ul>
<li>擦除和实化类型参数</li>
</ul>
<p>JVM 上的泛型一般是通过类型擦除实现的，泛型类实例的类型实参在运行时是不保留的。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">var</span> items = listOf(<span style="color:#e6db74">&#34;lhr&#34;</span>,<span style="color:#e6db74">&#34;lnx&#34;</span>,<span style="color:#ae81ff">2</span>)

<span style="color:#75715e">/**
</span><span style="color:#75715e"> * 运行时泛型被擦除了，无法判断List的类型
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">main</span>(args: Array&lt;String&gt;) {
    <span style="color:#66d9ef">if</span> (items <span style="color:#66d9ef">is</span> List&lt;String&gt;){

        <span style="color:#75715e">//...
</span><span style="color:#75715e"></span>    }
}
</code></pre></div><p><strong>声明带实化类型参数的函数(基于inline内联函数)</strong></p>
<p>Kotlin 有特殊的语法结构可以允许你在函数体中使用具体的类型泛型实参，但只有 inline 函数可以。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#75715e">/**
</span><span style="color:#75715e"> * 内联函数 reified声明了类型参数T不会在运行时被擦除
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">fun</span> &lt;reified T&gt; <span style="color:#a6e22e">Iterable</span>&lt;*&gt;.filterIsInstance():List&lt;T&gt;{
    <span style="color:#66d9ef">val</span> destination= mutableListOf&lt;T&gt;()
    <span style="color:#75715e">/*
</span><span style="color:#75715e">    对指定实参进行检测存储返回。
</span><span style="color:#75715e">    因为生成的字节码引用了具体类，而不是类型参数，它不会被运行时发生的类型参数擦除影响 。
</span><span style="color:#75715e">     */</span>
    <span style="color:#66d9ef">for</span>(element <span style="color:#66d9ef">in</span> <span style="color:#66d9ef">this</span>){
       <span style="color:#66d9ef">if</span> (element <span style="color:#66d9ef">is</span> T){
           destination.add(element)
       }
    }
    <span style="color:#66d9ef">return</span> destination;
}

<span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">main</span>(args: Array&lt;String&gt;) {
    <span style="color:#66d9ef">val</span> list = listOf(<span style="color:#e6db74">&#34;123&#34;</span>, <span style="color:#e6db74">&#34;456&#34;</span>, <span style="color:#ae81ff">999</span>)
    println(list.filterIsInstance&lt;String&gt;())
}
</code></pre></div><h3 id="泛型协变逆变和不变">泛型协变、逆变和不变</h3>
<h4 id="概念">概念</h4>
<p>假设Orange类是Fruit类的子类，Crate<!-- raw HTML omitted --> 是一个泛型类</p>
<pre><code>type variance（型变）:指我们是否允许对参数类型进行子类型转换
invariance（不型变）：也就是说，Crate&lt;Orange&gt; 和 Crate&lt;Fruit&gt; 之间没有关系
covariance（协变）：也就是说，Crate&lt;Orange&gt; 是 Crate&lt;Fruit&gt; 的子类型[Java Crate&lt;Orange&gt; 是 Crate&lt;? extends Fruit&gt; 的子类型]
contravariance（逆变）：也就是说，Crate&lt;Fruit&gt; 是 Crate&lt;Orange&gt; 的子类型。[Crate&lt;Fruit&gt; 是 Crate&lt;? super Orange&gt; 的子类型]
</code></pre><p><img src="https://user-images.githubusercontent.com/19829495/54437743-415c7b80-4770-11e9-9d1a-752a81c0c794.png" alt="image"></p>
<h4 id="java">Java</h4>
<p>Java处理型变的做法概括起来是：Java中的泛型类在正常使用时是不型变的，要想型变必须在使用处通过通配符进行（称为使用处型变）。</p>
<p><strong>协变</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">List&lt;? extends Fruit&gt; fruits = new ArrayList&lt;&gt;();
<span style="color:#75715e">//编译错误:不能添加任何类型的对象
</span><span style="color:#75715e">//fruits.add(new Orange());
</span><span style="color:#75715e">//fruits.add(new Fruit());
</span><span style="color:#75715e">//fruits.add(new Object());
</span><span style="color:#75715e">//我们知道，返回值肯定是Fruit
</span><span style="color:#75715e"></span>Fruit f = fruits.<span style="color:#66d9ef">get</span>(<span style="color:#ae81ff">0</span>);
</code></pre></div><p>fruits的类型是List&lt;? extends Fruit&gt;，代表Fruit类型或者从Fruit继承的类型的List，fruits可以引用诸如Fruit或Orange这样类型的List，然后向上转型为了List&lt;? extends Fruit&gt;。我们并不关心fruits具体引用的是<code>ArrayList&lt;Orange&gt;()</code>，还是<code>ArrayList&lt;Fruit&gt;()</code>，对于类型 List&lt;? extends Fruit&gt; 我们所能知道的就是：调用一个返回Fruit的方法是安全的，因为你知道，这个List中的任何对象至少具有Fruit类型。</p>
<p>我们之所以可以安全地将 ArrayList<!-- raw HTML omitted --> 向上转型为 List&lt;? extends Fruit&gt;，是因为编译器限制了我们对于 List&lt;? extends Fruit&gt; 类型部分方法的调用。例如void add(T t)方法，以及一切参数中含有 T 的方法（称为消费者方法）。因为这些方法可能会破坏类型安全，只要限制这些方法的调用，就可以安全地将 ArrayList<!-- raw HTML omitted --> 转型为 List&lt;? extends Fruit&gt;。</p>
<p>协变：通过限制对于消费者方法的调用，使得像 List&lt;? extends Fruit&gt; 这样的类型成为单纯的“生产者”，以保证运行时的类型安全</p>
<p><strong>逆变</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">List&lt;Object&gt; objs = new ArrayList&lt;&gt;();
objs.add(new Object());
List&lt;? <span style="color:#66d9ef">super</span> Fruit&gt; canContainFruits = objs;
<span style="color:#75715e">//没有问题，可以写入Fruit类及其子类
</span><span style="color:#75715e"></span>canContainFruits.add(new Orange());
canContainFruits.add(new Banana());
canContainFruits.add(new Fruit());
<span style="color:#75715e">//无法安全地读取,canContainFruits完全可能包含Fruit基类的对象，比如这里的Object
</span><span style="color:#75715e">//Fruit f = canContainFruits.get(0);
</span><span style="color:#75715e"></span>
<span style="color:#75715e">//总是可以读取为Object，然而这并没有太多意义
</span><span style="color:#75715e"></span>Object o = canContainFruits.<span style="color:#66d9ef">get</span>(<span style="color:#ae81ff">1</span>);
</code></pre></div><p>canContainFruits的类型是List&lt;? super Fruit&gt;，代表Fruit类型或者Fruit基类型的List，canContainFruits可以引用诸如Fruit或Object这样类型的List，然后向上转型为了List&lt;? super Fruit&gt;。对于List中的 T get(int pos) 方法，当指定类型是 “？ super Fruit”  时，get方法的返回类型就变成了 “？ super Fruit”，也就是说，返回类型可能是Fruit或者任意Fruit的基类型，我们不能确定，因此编译器拒绝调用任何返回类型为 T 的方法（除非我们只是读取为Object类）</p>
<p>逆变：编译器限制了我们对于 List&lt;? super Fruit&gt; 类型部分方法的调用。例如T get(int  pos)方法，以及一切返回类型为 T 的方法（称为生产者方法），因为我们不能确定这些方法的返回类型，只要限制这些方法的调用，就可以安全地将 ArrayList<!-- raw HTML omitted --> 转型为 List&lt;? super Fruit&gt;。这就是所谓的逆变，通过限制对于生产者方法的调用，使得像 List&lt;? super Fruit&gt; 这样的类型成为单纯的“消费者”。</p>
<p><strong>总结</strong></p>
<p>extends限定了通配符类型的上界，所以我们可以安全地从其中读取；而super限定了通配符类型的下界，所以我们可以安全地向其中写入。</p>
<h4 id="kotlin">Kotlin</h4>
<p>Kotlin中的泛型类在定义时即可标明型变类型（协变或逆变，当然也可以不标明，那就是不型变的），在使用处可以直接型变（称为声明处型变）。</p>
<p><strong>协变</strong></p>
<p>使用out修饰符，表明类型参数 T 在泛型类中仅作为方法的返回值，不作为方法的参数，因此，这个泛型类是个协变的。回报是，使用时Source<!-- raw HTML omitted -->可以作为Source<!-- raw HTML omitted -->的子类型。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">abstract</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Source</span>&lt;<span style="color:#66d9ef">out</span> T&gt; {
    <span style="color:#66d9ef">abstract</span> <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">nextT</span>(): T
}

<span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">demo</span>(oranges: Source&lt;Orange&gt;) {
    <span style="color:#66d9ef">val</span> fruits: Source&lt;Fruit&gt; = oranges <span style="color:#75715e">// 没问题，因为 T 是一个 out-参数，Source&lt;T&gt;是协变的
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">val</span> oneFruit: Fruit = fruits.nextT() <span style="color:#75715e">//可以安全读取
</span><span style="color:#75715e"></span>}
</code></pre></div><p><strong>逆变</strong></p>
<p>使用in修饰符，表明类型参数 T 在泛型类中仅作为方法的参数，不作为方法的返回值，因此，这个泛型类是个逆变的。回报是，使用时Comparable<!-- raw HTML omitted -->可以作为Comparable<!-- raw HTML omitted -->的子类型。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#75715e">//kotlin
</span><span style="color:#75715e"></span><span style="color:#66d9ef">abstract</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Comparable</span>&lt;<span style="color:#66d9ef">in</span> T&gt; {
    <span style="color:#66d9ef">abstract</span> <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">compareTo</span>(other: T): Int
}

<span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">demo</span>(x: Comparable&lt;Number&gt;) {
    <span style="color:#66d9ef">val</span> y: Comparable&lt;Double&gt; = x <span style="color:#75715e">// OK！逆变，Comparable&lt;Number&gt;可以作为Comparable&lt;Double&gt;的子类型
</span><span style="color:#75715e"></span>    y.compareTo(<span style="color:#ae81ff">1.0</span>) <span style="color:#75715e">//1.0 拥有类型 Double
</span><span style="color:#75715e"></span>}
</code></pre></div><p><strong>总结</strong></p>
<p>out和in修饰符是自解释的。out代表泛型类中，类型参数 T 只能存在于方法的返回值中，即是作为输出，因此，泛型类是生产者/协变的；in代表泛型类中，类型参数T只能存在于方法的参数中，即是作为输入，因此，泛型类是消费者/逆变的。</p>
<h3 id="注解">注解</h3>
<ul>
<li>
<p>注解实参需要在编译期就是己知的，所以你不能引用任意的属性作为实参。要把属性当作注解实参使用，你需要用const修饰符标记它，来告知编译器这个属性是编译期常量。</p>
</li>
<li>
<p>Kotlin 允许你对任意的表达式应用注解，而不仅仅是类和函数的声明及类型。</p>
</li>
<li>
<p>用注解控制JavaAPI</p>
</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#75715e">//volatile 多线程可见性
</span><span style="color:#75715e"></span>@volatile
<span style="color:#75715e">//Strictfp 多平台浮点数可预测性
</span><span style="color:#75715e"></span>@Strictfp
<span style="color:#75715e">//改变由 Kotlin 生成的 Java 方法或字段的名称 
</span><span style="color:#75715e"></span>@JvmName 
<span style="color:#75715e">//能被用在对象声明或者伴生对象的方法上，把它们暴露成
</span><span style="color:#75715e"></span>Java <span style="color:#960050;background-color:#1e0010">的静态方法</span>
@JvmStatic
<span style="color:#75715e">//指导 Kotlin 编译器为带默认参数值的函数生成多个重载
</span><span style="color:#75715e"></span>@JvmOverloads
<span style="color:#75715e">//应用于一个属性，把这个属性暴露成一个没有访问器的
</span><span style="color:#75715e"></span><span style="color:#960050;background-color:#1e0010">公有</span> Java <span style="color:#960050;background-color:#1e0010">字段。</span>
@JvmField 
</code></pre></div><ul>
<li>注解使用</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#75715e">//声明注解
</span><span style="color:#75715e">//@Target 元注解
</span><span style="color:#75715e"></span>@Target(AnnotationTarget.PROPERTY)
<span style="color:#66d9ef">annotation</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">xxx</span>
</code></pre></div><h3 id="dsl">DSL</h3>
<h4 id="关于dsl">关于DSL</h4>
<ul>
<li>
<p>DSL
DSL 也就是 Domain Specific Language 的简称，是指为某些特定领域（domain）设计的专用语言。最常见的 DSL 就是 SQL和正则表达式。和通用编程语言相反，DSL大部分是声明式的(声明式语言描述了想要的结果并将执行细节留给了解释它的引擎)。</p>
</li>
<li>
<p>内部DSL
与有着自己独立语法的外部 DSL 不同，内部 DSL是用通用编程语言编写的程序的一部分，使用了和通用编程语言完全一致的语法。实际上，内部 DSL 不是完全独立的语言，而是使用主要语言的特定方式，同时保留具有独立语法的 DSL 的主要优点。
[使用Kotlin 语言开发的，解决特定领域问题，具备独特代码结构的 API]</p>
</li>
<li>
<p>DSL结构
DSL 通常会依赖在其他上下文中也会广泛使用的语言特性，比如说中缀调用和运算符重载。DSL与API不同的显著特征是结构/文法。
与API的命令查询不同, DSL 的方法调用存在于由 DSL 文法定义的
更大的结构中。</p>
</li>
<li>
<p>Kotlin DSL
Kotiin 的 DSL 是完全静态类型的[编译时错误的检测，以及更好的 IDE 支持]。</p>
</li>
</ul>
<h4 id="kotlin-dsl使用">Kotlin DSL使用</h4>
<p><strong>利用带接收者的lambda和扩展函数实现HTML Table Sample DSL</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">open</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Tag</span>(<span style="color:#66d9ef">val</span> name: String) {

    <span style="color:#75715e">/**
</span><span style="color:#75715e">     * 保存所有嵌套标签
</span><span style="color:#75715e">     */</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">val</span> children = mutableListOf&lt;Tag&gt;()

    <span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">fun</span> &lt;T : Tag&gt; <span style="color:#a6e22e">doInit</span>(child: T, init: T. () -&gt; Unit) {
        <span style="color:#75715e">//调用作为参数的lambda,初始化并保存子标签
</span><span style="color:#75715e"></span>        child.init()
        children.add(child)
    }

    <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">toString</span>() = <span style="color:#e6db74">&#34;&lt;$name&gt;${children.joinToString(&#34;&#34;)} &lt;/$name&gt;&#34;</span>
}

<span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">table</span>(init: TABLE.() -&gt; Unit) = TABLE().apply(init)

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">TABLE</span> : Tag(<span style="color:#e6db74">&#34;table&#34;</span>) {
    <span style="color:#75715e">/**
</span><span style="color:#75715e">     * 创建并初始化 TR 标签的示例并添加到TABLE 的子标签中
</span><span style="color:#75715e">     */</span>
    <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">tr</span>(init: TR.() -&gt; Unit) = doInit(TR(), init)
}

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">TR</span> : Tag(<span style="color:#e6db74">&#34;tr&#34;</span>) {
    <span style="color:#75715e">/**
</span><span style="color:#75715e">     * 添加TD标签的一个实例到 TR 的子标签中
</span><span style="color:#75715e">     */</span>
    <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">td</span>(init: TD.() -&gt; Unit) = doInit(TD(), init)
}

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">TD</span> : Tag(<span style="color:#e6db74">&#34;td&#34;</span>)

<span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">main</span>(args: Array&lt;String&gt;) {
    <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">createTable</span>() =
            table {
                tr {
                    td { }
                    td { }
                }
            }
    <span style="color:#75715e">//&lt;table&gt;&lt;tr&gt;&lt;td&gt; &lt;/td&gt;&lt;td&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;
</span><span style="color:#75715e"></span>    println(createTable())
}
</code></pre></div><p><strong>关于带接收者的lambda与扩展函数</strong></p>
<p>让我们使用一个结构来构建 API。当函数被调用的时候需要提供这个对象，它在函数体内是可用的。实际上 ，一个扩展函数类型描述了一个可以被当作扩展函数来调用的代码块。</p>
<p>调用扩展函数类型lamdba时，可以像调用一个扩展函数那样调用 lambda，而不是将对象作为参数传递给 lambda。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#75715e">/**
</span><span style="color:#75715e"> * action: StringBuilder.() -&gt; Unit 定义接收者为StringBuilder的lambda
</span><span style="color:#75715e"> * StringBuilder.() -&gt; Unit 扩展函数
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">buildString</span>(action: StringBuilder.() -&gt; Unit):String{
    <span style="color:#66d9ef">val</span> sb = StringBuilder()
    <span style="color:#75715e">//传递一个 StringBuilder 实例作为lambda的接收者
</span><span style="color:#75715e"></span>    sb.action()
    <span style="color:#66d9ef">return</span> sb.toString()
}

<span style="color:#66d9ef">var</span> s = buildString {
    append(<span style="color:#e6db74">&#34;are you ok&#34;</span>)
}
</code></pre></div><p><strong>invoke约定</strong></p>
<p>invoke约定允许把自定义类型的对象当作函数一样调用。(类似于运算符重载)</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Person</span>(<span style="color:#66d9ef">val</span> name: String){
    <span style="color:#75715e">/**
</span><span style="color:#75715e">     * 重载invoke
</span><span style="color:#75715e">     */</span>
    <span style="color:#66d9ef">operator</span> <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">invoke</span>(no: String){
        println(<span style="color:#e6db74">&#34;$name - $no &#34;</span>)
    }
}

<span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">main</span>(args: Array&lt;String&gt;) {
    <span style="color:#66d9ef">val</span> person = Person(<span style="color:#e6db74">&#34;lhr&#34;</span>)
    person(<span style="color:#e6db74">&#34;cp272727&#34;</span>)<span style="color:#75715e">//实际上调用的是person.invoke
</span><span style="color:#75715e"></span>
}

</code></pre></div><p><strong>中缀调用 DSL清晰的语法</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">object</span> <span style="color:#a6e22e">start</span>

<span style="color:#66d9ef">infix</span> <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">String</span>.should(x: start): StartWrapper = StartWrapper(<span style="color:#66d9ef">this</span>)

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">StartWrapper</span>(<span style="color:#66d9ef">val</span> value: String) {
    <span style="color:#66d9ef">infix</span> <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">with</span>(prefix: String): Unit =
            <span style="color:#66d9ef">if</span> (value.startsWith(prefix)) {
            } <span style="color:#66d9ef">else</span> {
                <span style="color:#66d9ef">throw</span> AssertionError(<span style="color:#e6db74">&#34;String does not start with $prefix: $value&#34;</span>)
            }

}

<span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">main</span>(args: Array&lt;String&gt;) {
    <span style="color:#e6db74">&#34;kotlin&#34;</span> should start with <span style="color:#e6db74">&#34;ko&#34;</span>
}
</code></pre></div><p><strong>基本数据类型扩展</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">val</span> Int.days: Period
    <span style="color:#75715e">//this 引用数字常量值
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">get</span>() = Period . ofDays (<span style="color:#66d9ef">this</span>)

<span style="color:#66d9ef">val</span> Period.ago:LocalDate
    <span style="color:#66d9ef">get</span>() = LocalDate.now() - <span style="color:#66d9ef">this</span>

<span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">main</span>(args: Array&lt;String&gt;) {
    <span style="color:#75715e">//获取一天前日期
</span><span style="color:#75715e"></span>    println(<span style="color:#ae81ff">1.</span>days.ago)
}
</code></pre></div><h3 id="协程相关">协程相关</h3>
<p>参考: <a href="http://johnnyshieh.me/categories/kotlin/">http://johnnyshieh.me/categories/kotlin/</a></p>


      
        <div class="blog-tags">
          
            <a
              href="https://chinalhr.github.io/tags/kotlin/"
              >Kotlin</a
            >&nbsp;
          
        </div>
      
    </article>
    
      <script>
  var backtotopButton = document.getElementById('backtotopButton')

  document.addEventListener('scroll', function () {
    if (
      document.body.scrollTop > 50 ||
      document.documentElement.scrollTop > 50
    ) {
      backtotopButton.style.opacity = '1'
    } else {
      backtotopButton.style.opacity = '0'
    }
  })

  function topFunction() {
    document.body.scrollTop = 0 
    document.documentElement.scrollTop = 0 
  }

  
  document.dispatchEvent(new CustomEvent('scroll'))
  backtotopButton.style.display = 'block'
</script>

      <button onclick="topFunction()" id="backtotopButton">
        <em class="fa fa-angle-up"></em>
      </button>
      <script>
  var backtotopButton = document.getElementById('backtotopButton')

  document.addEventListener('scroll', function () {
    if (
      document.body.scrollTop > 50 ||
      document.documentElement.scrollTop > 50
    ) {
      backtotopButton.style.opacity = '1'
    } else {
      backtotopButton.style.opacity = '0'
    }
  })

  function topFunction() {
    document.body.scrollTop = 0 
    document.documentElement.scrollTop = 0 
  }

  
  document.dispatchEvent(new CustomEvent('scroll'))
  backtotopButton.style.display = 'block'
</script>

    
    
      

    
  </div>

    <footer>
  

<div class="social-icons">
  
    
    
      
      <a href="https://github.com/chinalhr" name="GitHub">
        <em class="fab fa-github"></em>
      </a>
    
       &nbsp;&ndash;&nbsp;
      <a href="mailto:13435500980@163.com" name="Email">
        <em class="fas fa-envelope"></em>
      </a>
    
  

  
</div>


  
  <div class="container">
    <p class="credits copyright">
      <a href="https://chinalhr.github.io/about">hanrong.li</a>
      &nbsp;&copy;
      2022
      
        &nbsp;/&nbsp;
        <a href="https://chinalhr.github.io/">ChinaLHR Blog</a>
      
      &nbsp;&ndash;&nbsp;
      <em class="fas fa-moon" id="dark-mode-toggle"></em>
    </p>

    <p class="credits theme-by">
      Powered By <a href="https://gohugo.io">Hugo</a>&nbsp;
      Theme
      <a href="https://github.com/matsuyoshi30/harbor">Harbor</a>
    </p>
  </div>
</footer>

  </body>
</html>
