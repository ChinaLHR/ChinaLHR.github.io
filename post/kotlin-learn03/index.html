<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Kotlin 泛型,注解,DSL - LiHanRong Blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="LHR" /><meta name="description" content=" Kotlin学习记录
" /><meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.51 with even 4.0.0" />


<link rel="canonical" href="https://chinalhr.github.io/post/kotlin-learn03/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<link href="/dist/even.c2a46f00.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Kotlin 泛型,注解,DSL" />
<meta property="og:description" content="
Kotlin学习记录
" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://chinalhr.github.io/post/kotlin-learn03/" /><meta property="article:published_time" content="2019-03-14T20:49:49&#43;08:00"/>
<meta property="article:modified_time" content="2019-03-14T20:49:49&#43;08:00"/>

<meta itemprop="name" content="Kotlin 泛型,注解,DSL">
<meta itemprop="description" content="
Kotlin学习记录
">


<meta itemprop="datePublished" content="2019-03-14T20:49:49&#43;08:00" />
<meta itemprop="dateModified" content="2019-03-14T20:49:49&#43;08:00" />
<meta itemprop="wordCount" content="3872">



<meta itemprop="keywords" content="Kotlin," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Kotlin 泛型,注解,DSL"/>
<meta name="twitter:description" content="
Kotlin学习记录
"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">LiHanRong Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/post/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/post/resume/">
        <li class="mobile-menu-item">Resume</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">LiHanRong Blog</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/resume/">Resume</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Kotlin 泛型,注解,DSL</h1>

      <div class="post-meta">
        <span class="post-time"> 2019-03-14 </span>
        <div class="post-category">
            <a href="/categories/%E7%BC%96%E7%A8%8B/"> 编程 </a>
            </div>
        <span id="busuanzi_container_page_pv" class="more-meta"> <span id="busuanzi_value_page_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> times read </span>
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
<ul>
<li>
<ul>
<li>
<ul>
<li><a href="#泛型">泛型</a></li>
<li><a href="#泛型协变-逆变和不变">泛型协变、逆变和不变</a>
<ul>
<li><a href="#概念">概念</a></li>
<li><a href="#java">Java</a></li>
<li><a href="#kotlin">Kotlin</a></li>
</ul></li>
<li><a href="#注解">注解</a></li>
<li><a href="#dsl">DSL</a>
<ul>
<li><a href="#关于dsl">关于DSL</a></li>
<li><a href="#kotlin-dsl使用">Kotlin DSL使用</a></li>
</ul></li>
<li><a href="#协程相关">协程相关</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <blockquote>
<p>Kotlin学习记录</p>
</blockquote>

<h3 id="泛型">泛型</h3>

<ul>
<li>对比Java</li>
</ul>

<p>和 Java 不同， Kotlin 始终要求类型实参要么被显式地说明，要么能被编译器推导出来。(因为Java有历史包袱,1.5才引入泛型)</p>

<ul>
<li>泛型类型约束</li>
</ul>

<p>约束上界 : &lt; T : Number&gt; T sum(List &lt; T&gt; list)</p>

<ul>
<li>擦除和实化类型参数</li>
</ul>

<p>JVM 上的泛型一般是通过类型擦除实现的，泛型类实例的类型实参在运行时是不保留的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-kotlin" data-lang="kotlin"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-kotlin" data-lang="kotlin"><span class="k">var</span> <span class="py">items</span> <span class="p">=</span> <span class="n">listOf</span><span class="p">(</span><span class="s">&#34;lhr&#34;</span><span class="p">,</span><span class="s">&#34;lnx&#34;</span><span class="p">,</span><span class="m">2</span><span class="p">)</span>

<span class="cm">/**
</span><span class="cm"> * 运行时泛型被擦除了，无法判断List的类型
</span><span class="cm"> */</span>
<span class="k">fun</span> <span class="nf">main</span><span class="p">(</span><span class="n">args</span><span class="p">:</span> <span class="n">Array</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">items</span> <span class="k">is</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;){</span>

        <span class="c1">//...
</span><span class="c1"></span>    <span class="p">}</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p><strong>声明带实化类型参数的函数(基于inline内联函数)</strong></p>

<p>Kotlin 有特殊的语法结构可以允许你在函数体中使用具体的类型泛型实参，但只有 inline 函数可以。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-kotlin" data-lang="kotlin"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-kotlin" data-lang="kotlin"><span class="cm">/**
</span><span class="cm"> * 内联函数 reified声明了类型参数T不会在运行时被擦除
</span><span class="cm"> */</span>
<span class="k">inline</span> <span class="k">fun</span> &lt;reified T&gt; <span class="nf">Iterable</span><span class="p">&lt;*&gt;.</span><span class="n">filterIsInstance</span><span class="p">():</span><span class="n">List</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;{</span>
    <span class="k">val</span> <span class="py">destination</span><span class="p">=</span> <span class="n">mutableListOf</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;()</span>
    <span class="cm">/*
</span><span class="cm">    对指定实参进行检测存储返回。
</span><span class="cm">    因为生成的字节码引用了具体类，而不是类型参数，它不会被运行时发生的类型参数擦除影响 。
</span><span class="cm">     */</span>
    <span class="k">for</span><span class="p">(</span><span class="n">element</span> <span class="k">in</span> <span class="k">this</span><span class="p">){</span>
       <span class="k">if</span> <span class="p">(</span><span class="n">element</span> <span class="k">is</span> <span class="n">T</span><span class="p">){</span>
           <span class="n">destination</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
       <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">destination</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">fun</span> <span class="nf">main</span><span class="p">(</span><span class="n">args</span><span class="p">:</span> <span class="n">Array</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;)</span> <span class="p">{</span>
    <span class="k">val</span> <span class="py">list</span> <span class="p">=</span> <span class="n">listOf</span><span class="p">(</span><span class="s">&#34;123&#34;</span><span class="p">,</span> <span class="s">&#34;456&#34;</span><span class="p">,</span> <span class="m">999</span><span class="p">)</span>
    <span class="n">println</span><span class="p">(</span><span class="n">list</span><span class="p">.</span><span class="n">filterIsInstance</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;())</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<h3 id="泛型协变-逆变和不变">泛型协变、逆变和不变</h3>

<h4 id="概念">概念</h4>

<p>假设Orange类是Fruit类的子类，Crate<T> 是一个泛型类</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></pre></td>
<td class="lntd">
<pre class="chroma">type variance（型变）:指我们是否允许对参数类型进行子类型转换
invariance（不型变）：也就是说，Crate&lt;Orange&gt; 和 Crate&lt;Fruit&gt; 之间没有关系
covariance（协变）：也就是说，Crate&lt;Orange&gt; 是 Crate&lt;Fruit&gt; 的子类型[Java Crate&lt;Orange&gt; 是 Crate&lt;? extends Fruit&gt; 的子类型]
contravariance（逆变）：也就是说，Crate&lt;Fruit&gt; 是 Crate&lt;Orange&gt; 的子类型。[Crate&lt;Fruit&gt; 是 Crate&lt;? super Orange&gt; 的子类型]</pre></td></tr></table>
</div>
</div>
<p><img src="https://user-images.githubusercontent.com/19829495/54437743-415c7b80-4770-11e9-9d1a-752a81c0c794.png" alt="image" /></p>

<h4 id="java">Java</h4>

<p>Java处理型变的做法概括起来是：Java中的泛型类在正常使用时是不型变的，要想型变必须在使用处通过通配符进行（称为使用处型变）。</p>

<p><strong>协变</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-kotlin" data-lang="kotlin"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-kotlin" data-lang="kotlin"><span class="n">List</span><span class="p">&lt;?</span> <span class="n">extends</span> <span class="n">Fruit</span><span class="p">&gt;</span> <span class="n">fruits</span> <span class="p">=</span> <span class="n">new</span> <span class="n">ArrayList</span><span class="p">&lt;</span><span class="n">Orange</span><span class="p">&gt;();</span>
<span class="c1">//编译错误:不能添加任何类型的对象
</span><span class="c1">//fruits.add(new Orange());
</span><span class="c1">//fruits.add(new Fruit());
</span><span class="c1">//fruits.add(new Object());
</span><span class="c1">//我们知道，返回值肯定是Fruit
</span><span class="c1"></span><span class="n">Fruit</span> <span class="n">f</span> <span class="p">=</span> <span class="n">fruits</span><span class="p">.</span><span class="k">get</span><span class="p">(</span><span class="m">0</span><span class="p">);</span></code></pre></td></tr></table>
</div>
</div>
<p>fruits的类型是List&lt;? extends Fruit&gt;，代表Fruit类型或者从Fruit继承的类型的List，fruits可以引用诸如Fruit或Orange这样类型的List，然后向上转型为了List&lt;? extends Fruit&gt;。我们并不关心fruits具体引用的是ArrayList<Orange>()，还是ArrayList<Fruit>()，对于类型 List&lt;? extends Fruit&gt; 我们所能知道的就是：调用一个返回Fruit的方法是安全的，因为你知道，这个List中的任何对象至少具有Fruit类型。</p>

<p>我们之所以可以安全地将 ArrayList<Orange> 向上转型为 List&lt;? extends Fruit&gt;，是因为编译器限制了我们对于 List&lt;? extends Fruit&gt; 类型部分方法的调用。例如void add(T t)方法，以及一切参数中含有 T 的方法（称为消费者方法）。因为这些方法可能会破坏类型安全，只要限制这些方法的调用，就可以安全地将 ArrayList<Orange> 转型为 List&lt;? extends Fruit&gt;。</p>

<p>协变：通过限制对于消费者方法的调用，使得像 List&lt;? extends Fruit&gt; 这样的类型成为单纯的“生产者”，以保证运行时的类型安全</p>

<p><strong>逆变</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-kotlin" data-lang="kotlin"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-kotlin" data-lang="kotlin"><span class="n">List</span><span class="p">&lt;</span><span class="n">Object</span><span class="p">&gt;</span> <span class="n">objs</span> <span class="p">=</span> <span class="n">new</span> <span class="n">ArrayList</span><span class="p">&lt;</span><span class="n">Object</span><span class="p">&gt;();</span>
<span class="n">objs</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">new</span> <span class="n">Object</span><span class="p">());</span>
<span class="n">List</span><span class="p">&lt;?</span> <span class="k">super</span> <span class="n">Fruit</span><span class="p">&gt;</span> <span class="n">canContainFruits</span> <span class="p">=</span> <span class="n">objs</span><span class="p">;</span>
<span class="c1">//没有问题，可以写入Fruit类及其子类
</span><span class="c1"></span><span class="n">canContainFruits</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">new</span> <span class="n">Orange</span><span class="p">());</span>
<span class="n">canContainFruits</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">new</span> <span class="n">Banana</span><span class="p">());</span>
<span class="n">canContainFruits</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">new</span> <span class="n">Fruit</span><span class="p">());</span>
<span class="c1">//无法安全地读取,canContainFruits完全可能包含Fruit基类的对象，比如这里的Object
</span><span class="c1">//Fruit f = canContainFruits.get(0);
</span><span class="c1"></span>
<span class="c1">//总是可以读取为Object，然而这并没有太多意义
</span><span class="c1"></span><span class="n">Object</span> <span class="n">o</span> <span class="p">=</span> <span class="n">canContainFruits</span><span class="p">.</span><span class="k">get</span><span class="p">(</span><span class="m">1</span><span class="p">);</span></code></pre></td></tr></table>
</div>
</div>
<p>canContainFruits的类型是List&lt;? super Fruit&gt;，代表Fruit类型或者Fruit基类型的List，canContainFruits可以引用诸如Fruit或Object这样类型的List，然后向上转型为了List&lt;? super Fruit&gt;。对于List中的 T get(int pos) 方法，当指定类型是 “？ super Fruit”  时，get方法的返回类型就变成了 “？ super Fruit”，也就是说，返回类型可能是Fruit或者任意Fruit的基类型，我们不能确定，因此编译器拒绝调用任何返回类型为 T 的方法（除非我们只是读取为Object类）</p>

<p>逆变：编译器限制了我们对于 List&lt;? super Fruit&gt; 类型部分方法的调用。例如T get(int  pos)方法，以及一切返回类型为 T 的方法（称为生产者方法），因为我们不能确定这些方法的返回类型，只要限制这些方法的调用，就可以安全地将 ArrayList<Object> 转型为 List&lt;? super Fruit&gt;。这就是所谓的逆变，通过限制对于生产者方法的调用，使得像 List&lt;? super Fruit&gt; 这样的类型成为单纯的“消费者”。</p>

<p><strong>总结</strong></p>

<p>extends限定了通配符类型的上界，所以我们可以安全地从其中读取；而super限定了通配符类型的下界，所以我们可以安全地向其中写入。</p>

<h4 id="kotlin">Kotlin</h4>

<p>Kotlin中的泛型类在定义时即可标明型变类型（协变或逆变，当然也可以不标明，那就是不型变的），在使用处可以直接型变（称为声明处型变）。</p>

<p><strong>协变</strong></p>

<p>使用out修饰符，表明类型参数 T 在泛型类中仅作为方法的返回值，不作为方法的参数，因此，这个泛型类是个协变的。回报是，使用时Source<Orange>可以作为Source<Fruit>的子类型。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-kotlin" data-lang="kotlin"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-kotlin" data-lang="kotlin"><span class="k">abstract</span> <span class="k">class</span> <span class="nc">Source</span><span class="p">&lt;</span><span class="k">out</span> <span class="n">T</span><span class="p">&gt;</span> <span class="p">{</span>
    <span class="k">abstract</span> <span class="k">fun</span> <span class="nf">nextT</span><span class="p">():</span> <span class="n">T</span>
<span class="p">}</span>

<span class="k">fun</span> <span class="nf">demo</span><span class="p">(</span><span class="n">oranges</span><span class="p">:</span> <span class="n">Source</span><span class="p">&lt;</span><span class="n">Orange</span><span class="p">&gt;)</span> <span class="p">{</span>
    <span class="k">val</span> <span class="py">fruits</span><span class="p">:</span> <span class="n">Source</span><span class="p">&lt;</span><span class="n">Fruit</span><span class="p">&gt;</span> <span class="p">=</span> <span class="n">oranges</span> <span class="c1">// 没问题，因为 T 是一个 out-参数，Source&lt;T&gt;是协变的
</span><span class="c1"></span>    <span class="k">val</span> <span class="py">oneFruit</span><span class="p">:</span> <span class="n">Fruit</span> <span class="p">=</span> <span class="n">fruits</span><span class="p">.</span><span class="n">nextT</span><span class="p">()</span> <span class="c1">//可以安全读取
</span><span class="c1"></span><span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p><strong>逆变</strong></p>

<p>使用in修饰符，表明类型参数 T 在泛型类中仅作为方法的参数，不作为方法的返回值，因此，这个泛型类是个逆变的。回报是，使用时Comparable<Number>可以作为Comparable<Double>的子类型。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-kotlin" data-lang="kotlin"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-kotlin" data-lang="kotlin"><span class="c1">//kotlin
</span><span class="c1"></span><span class="k">abstract</span> <span class="k">class</span> <span class="nc">Comparable</span><span class="p">&lt;</span><span class="k">in</span> <span class="n">T</span><span class="p">&gt;</span> <span class="p">{</span>
    <span class="k">abstract</span> <span class="k">fun</span> <span class="nf">compareTo</span><span class="p">(</span><span class="n">other</span><span class="p">:</span> <span class="n">T</span><span class="p">):</span> <span class="n">Int</span>
<span class="p">}</span>

<span class="k">fun</span> <span class="nf">demo</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Comparable</span><span class="p">&lt;</span><span class="n">Number</span><span class="p">&gt;)</span> <span class="p">{</span>
    <span class="k">val</span> <span class="py">y</span><span class="p">:</span> <span class="n">Comparable</span><span class="p">&lt;</span><span class="n">Double</span><span class="p">&gt;</span> <span class="p">=</span> <span class="n">x</span> <span class="c1">// OK！逆变，Comparable&lt;Number&gt;可以作为Comparable&lt;Double&gt;的子类型
</span><span class="c1"></span>    <span class="n">y</span><span class="p">.</span><span class="n">compareTo</span><span class="p">(</span><span class="m">1.0</span><span class="p">)</span> <span class="c1">//1.0 拥有类型 Double
</span><span class="c1"></span><span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p><strong>总结</strong></p>

<p>out和in修饰符是自解释的。out代表泛型类中，类型参数 T 只能存在于方法的返回值中，即是作为输出，因此，泛型类是生产者/协变的；in代表泛型类中，类型参数T只能存在于方法的参数中，即是作为输入，因此，泛型类是消费者/逆变的。</p>

<h3 id="注解">注解</h3>

<ul>
<li><p>注解实参需要在编译期就是己知的，所以你不能引用任意的属性作为实参。要把属性当作注解实参使用，你需要用const修饰符标记它，来告知编译器这个属性是编译期常量。</p></li>

<li><p>Kotlin 允许你对任意的表达式应用注解，而不仅仅是类和函数的声明及类型。</p></li>

<li><p>用注解控制JavaAPI</p></li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-kotlin" data-lang="kotlin"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-kotlin" data-lang="kotlin"><span class="c1">//volatile 多线程可见性
</span><span class="c1"></span><span class="n">@volatile</span>
<span class="c1">//Strictfp 多平台浮点数可预测性
</span><span class="c1"></span><span class="n">@Strictfp</span>
<span class="c1">//改变由 Kotlin 生成的 Java 方法或字段的名称 
</span><span class="c1"></span><span class="n">@JvmName</span> 
<span class="c1">//能被用在对象声明或者伴生对象的方法上，把它们暴露成
</span><span class="c1"></span><span class="n">Java</span> <span class="err">的静态方法</span>
<span class="n">@JvmStatic</span>
<span class="c1">//指导 Kotlin 编译器为带默认参数值的函数生成多个重载
</span><span class="c1"></span><span class="n">@JvmOverloads</span>
<span class="c1">//应用于一个属性，把这个属性暴露成一个没有访问器的
</span><span class="c1"></span><span class="err">公有</span> <span class="n">Java</span> <span class="err">字段。</span>
<span class="n">@JvmField</span> </code></pre></td></tr></table>
</div>
</div>
<ul>
<li>注解使用</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-kotlin" data-lang="kotlin"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-kotlin" data-lang="kotlin"><span class="c1">//声明注解
</span><span class="c1">//@Target 元注解
</span><span class="c1"></span><span class="n">@Target</span><span class="p">(</span><span class="n">AnnotationTarget</span><span class="p">.</span><span class="n">PROPERTY</span><span class="p">)</span>
<span class="k">annotation</span> <span class="k">class</span> <span class="nc">xxx</span></code></pre></td></tr></table>
</div>
</div>
<h3 id="dsl">DSL</h3>

<h4 id="关于dsl">关于DSL</h4>

<ul>
<li><p>DSL
DSL 也就是 Domain Specific Language 的简称，是指为某些特定领域（domain）设计的专用语言。最常见的 DSL 就是 SQL和正则表达式。和通用编程语言相反，DSL大部分是声明式的(声明式语言描述了想要的结果并将执行细节留给了解释它的引擎)。</p></li>

<li><p>内部DSL
与有着自己独立语法的外部 DSL 不同，内部 DSL是用通用编程语言编写的程序的一部分，使用了和通用编程语言完全一致的语法。实际上，内部 DSL 不是完全独立的语言，而是使用主要语言的特定方式，同时保留具有独立语法的 DSL 的主要优点。
[使用Kotlin 语言开发的，解决特定领域问题，具备独特代码结构的 API]</p></li>

<li><p>DSL结构
DSL 通常会依赖在其他上下文中也会广泛使用的语言特性，比如说中缀调用和运算符重载。DSL与API不同的显著特征是结构/文法。
与API的命令查询不同, DSL 的方法调用存在于由 DSL 文法定义的
更大的结构中。</p></li>

<li><p>Kotlin DSL
Kotiin 的 DSL 是完全静态类型的[编译时错误的检测，以及更好的 IDE 支持]。</p></li>
</ul>

<h4 id="kotlin-dsl使用">Kotlin DSL使用</h4>

<p><strong>利用带接收者的lambda和扩展函数实现HTML Table Sample DSL</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-kotlin" data-lang="kotlin"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-kotlin" data-lang="kotlin"><span class="k">open</span> <span class="k">class</span> <span class="nc">Tag</span><span class="p">(</span><span class="k">val</span> <span class="py">name</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span>

    <span class="cm">/**
</span><span class="cm">     * 保存所有嵌套标签
</span><span class="cm">     */</span>
    <span class="k">private</span> <span class="k">val</span> <span class="py">children</span> <span class="p">=</span> <span class="n">mutableListOf</span><span class="p">&lt;</span><span class="n">Tag</span><span class="p">&gt;()</span>

    <span class="k">protected</span> <span class="k">fun</span> &lt;T : Tag&gt; <span class="nf">doInit</span><span class="p">(</span><span class="n">child</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span> <span class="n">init</span><span class="p">:</span> <span class="n">T</span><span class="p">.</span> <span class="p">()</span> <span class="p">-&gt;</span> <span class="n">Unit</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">//调用作为参数的lambda,初始化并保存子标签
</span><span class="c1"></span>        <span class="n">child</span><span class="p">.</span><span class="n">init</span><span class="p">()</span>
        <span class="n">children</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">override</span> <span class="k">fun</span> <span class="nf">toString</span><span class="p">()</span> <span class="p">=</span> <span class="s">&#34;&lt;$name&gt;${children.joinToString(&#34;&#34;)} &lt;/$name&gt;&#34;</span>
<span class="p">}</span>

<span class="k">fun</span> <span class="nf">table</span><span class="p">(</span><span class="n">init</span><span class="p">:</span> <span class="n">TABLE</span><span class="p">.()</span> <span class="p">-&gt;</span> <span class="n">Unit</span><span class="p">)</span> <span class="p">=</span> <span class="n">TABLE</span><span class="p">().</span><span class="n">apply</span><span class="p">(</span><span class="n">init</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">TABLE</span> <span class="p">:</span> <span class="n">Tag</span><span class="p">(</span><span class="s">&#34;table&#34;</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/**
</span><span class="cm">     * 创建并初始化 TR 标签的示例并添加到TABLE 的子标签中
</span><span class="cm">     */</span>
    <span class="k">fun</span> <span class="nf">tr</span><span class="p">(</span><span class="n">init</span><span class="p">:</span> <span class="n">TR</span><span class="p">.()</span> <span class="p">-&gt;</span> <span class="n">Unit</span><span class="p">)</span> <span class="p">=</span> <span class="n">doInit</span><span class="p">(</span><span class="n">TR</span><span class="p">(),</span> <span class="n">init</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">TR</span> <span class="p">:</span> <span class="n">Tag</span><span class="p">(</span><span class="s">&#34;tr&#34;</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/**
</span><span class="cm">     * 添加TD标签的一个实例到 TR 的子标签中
</span><span class="cm">     */</span>
    <span class="k">fun</span> <span class="nf">td</span><span class="p">(</span><span class="n">init</span><span class="p">:</span> <span class="n">TD</span><span class="p">.()</span> <span class="p">-&gt;</span> <span class="n">Unit</span><span class="p">)</span> <span class="p">=</span> <span class="n">doInit</span><span class="p">(</span><span class="n">TD</span><span class="p">(),</span> <span class="n">init</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">TD</span> <span class="p">:</span> <span class="n">Tag</span><span class="p">(</span><span class="s">&#34;td&#34;</span><span class="p">)</span>

<span class="k">fun</span> <span class="nf">main</span><span class="p">(</span><span class="n">args</span><span class="p">:</span> <span class="n">Array</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;)</span> <span class="p">{</span>
    <span class="k">fun</span> <span class="nf">createTable</span><span class="p">()</span> <span class="p">=</span>
            <span class="n">table</span> <span class="p">{</span>
                <span class="n">tr</span> <span class="p">{</span>
                    <span class="n">td</span> <span class="p">{</span> <span class="p">}</span>
                    <span class="n">td</span> <span class="p">{</span> <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>
    <span class="c1">//&lt;table&gt;&lt;tr&gt;&lt;td&gt; &lt;/td&gt;&lt;td&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;
</span><span class="c1"></span>    <span class="n">println</span><span class="p">(</span><span class="n">createTable</span><span class="p">())</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p><strong>关于带接收者的lambda与扩展函数</strong></p>

<p>让我们使用一个结构来构建 API。当函数被调用的时候需要提供这个对象，它在函数体内是可用的。实际上 ，一个扩展函数类型描述了一个可以被当作扩展函数来调用的代码块。</p>

<p>调用扩展函数类型lamdba时，可以像调用一个扩展函数那样调用 lambda，而不是将对象作为参数传递给 lambda。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-kotlin" data-lang="kotlin"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-kotlin" data-lang="kotlin"><span class="cm">/**
</span><span class="cm"> * action: StringBuilder.() -&gt; Unit 定义接收者为StringBuilder的lambda
</span><span class="cm"> * StringBuilder.() -&gt; Unit 扩展函数
</span><span class="cm"> */</span>
<span class="k">fun</span> <span class="nf">buildString</span><span class="p">(</span><span class="n">action</span><span class="p">:</span> <span class="n">StringBuilder</span><span class="p">.()</span> <span class="p">-&gt;</span> <span class="n">Unit</span><span class="p">):</span><span class="n">String</span><span class="p">{</span>
    <span class="k">val</span> <span class="py">sb</span> <span class="p">=</span> <span class="n">StringBuilder</span><span class="p">()</span>
    <span class="c1">//传递一个 StringBuilder 实例作为lambda的接收者
</span><span class="c1"></span>    <span class="n">sb</span><span class="p">.</span><span class="n">action</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">sb</span><span class="p">.</span><span class="n">toString</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">var</span> <span class="py">s</span> <span class="p">=</span> <span class="n">buildString</span> <span class="p">{</span>
    <span class="n">append</span><span class="p">(</span><span class="s">&#34;are you ok&#34;</span><span class="p">)</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p><strong>invoke约定</strong></p>

<p>invoke约定允许把自定义类型的对象当作函数一样调用。(类似于运算符重载)</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-kotlin" data-lang="kotlin"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-kotlin" data-lang="kotlin"><span class="k">class</span> <span class="nc">Person</span><span class="p">(</span><span class="k">val</span> <span class="py">name</span><span class="p">:</span> <span class="n">String</span><span class="p">){</span>
    <span class="cm">/**
</span><span class="cm">     * 重载invoke
</span><span class="cm">     */</span>
    <span class="k">operator</span> <span class="k">fun</span> <span class="nf">invoke</span><span class="p">(</span><span class="n">no</span><span class="p">:</span> <span class="n">String</span><span class="p">){</span>
        <span class="n">println</span><span class="p">(</span><span class="s">&#34;$name - $no &#34;</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fun</span> <span class="nf">main</span><span class="p">(</span><span class="n">args</span><span class="p">:</span> <span class="n">Array</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;)</span> <span class="p">{</span>
    <span class="k">val</span> <span class="py">person</span> <span class="p">=</span> <span class="n">Person</span><span class="p">(</span><span class="s">&#34;lhr&#34;</span><span class="p">)</span>
    <span class="n">person</span><span class="p">(</span><span class="s">&#34;cp272727&#34;</span><span class="p">)</span><span class="c1">//实际上调用的是person.invoke
</span><span class="c1"></span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p><strong>中缀调用 DSL清晰的语法</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-kotlin" data-lang="kotlin"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-kotlin" data-lang="kotlin"><span class="k">object</span> <span class="nc">start</span>

<span class="k">infix</span> <span class="k">fun</span> <span class="nf">String</span><span class="p">.</span><span class="n">should</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">start</span><span class="p">):</span> <span class="n">StartWrapper</span> <span class="p">=</span> <span class="n">StartWrapper</span><span class="p">(</span><span class="k">this</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">StartWrapper</span><span class="p">(</span><span class="k">val</span> <span class="py">value</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">infix</span> <span class="k">fun</span> <span class="nf">with</span><span class="p">(</span><span class="n">prefix</span><span class="p">:</span> <span class="n">String</span><span class="p">):</span> <span class="n">Unit</span> <span class="p">=</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">value</span><span class="p">.</span><span class="n">startsWith</span><span class="p">(</span><span class="n">prefix</span><span class="p">))</span> <span class="p">{</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">throw</span> <span class="n">AssertionError</span><span class="p">(</span><span class="s">&#34;String does not start with $prefix: $value&#34;</span><span class="p">)</span>
            <span class="p">}</span>

<span class="p">}</span>

<span class="k">fun</span> <span class="nf">main</span><span class="p">(</span><span class="n">args</span><span class="p">:</span> <span class="n">Array</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;)</span> <span class="p">{</span>
    <span class="s">&#34;kotlin&#34;</span> <span class="n">should</span> <span class="n">start</span> <span class="n">with</span> <span class="s">&#34;ko&#34;</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p><strong>基本数据类型扩展</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-kotlin" data-lang="kotlin"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-kotlin" data-lang="kotlin"><span class="k">val</span> <span class="py">Int</span><span class="p">.</span><span class="n">days</span><span class="p">:</span> <span class="n">Period</span>
    <span class="c1">//this 引用数字常量值
</span><span class="c1"></span>    <span class="k">get</span><span class="p">()</span> <span class="p">=</span> <span class="n">Period</span> <span class="p">.</span> <span class="n">ofDays</span> <span class="p">(</span><span class="k">this</span><span class="p">)</span>

<span class="k">val</span> <span class="py">Period</span><span class="p">.</span><span class="n">ago</span><span class="p">:</span><span class="n">LocalDate</span>
    <span class="k">get</span><span class="p">()</span> <span class="p">=</span> <span class="n">LocalDate</span><span class="p">.</span><span class="n">now</span><span class="p">()</span> <span class="p">-</span> <span class="k">this</span>

<span class="k">fun</span> <span class="nf">main</span><span class="p">(</span><span class="n">args</span><span class="p">:</span> <span class="n">Array</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;)</span> <span class="p">{</span>
    <span class="c1">//获取一天前日期
</span><span class="c1"></span>    <span class="n">println</span><span class="p">(</span><span class="m">1.</span><span class="n">days</span><span class="p">.</span><span class="n">ago</span><span class="p">)</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<h3 id="协程相关">协程相关</h3>

<p>参考: <a href="http://johnnyshieh.me/categories/kotlin/">http://johnnyshieh.me/categories/kotlin/</a></p>
    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">Author</span>
    <span class="item-content">LHR</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">LastMod</span>
    <span class="item-content">
        2019-03-14
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/kotlin/">Kotlin</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/reactivewebstack/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">响应式Web技术栈</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/kotlin-learn02/">
            <span class="next-text nav-default">Kotlin 类型系统，语言特性</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        
  
  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="13435500980@163.com" class="iconfont icon-email" title="email"></a>
      <a href="https://github.com/ChinaLHR" class="iconfont icon-github" title="github"></a>
      <a href="https://weibo.com/u/2841104477" class="iconfont icon-weibo" title="weibo"></a>
  <a href="https://chinalhr.github.io/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
      友情链接：<a class="theme-link" href="https://www.bfreeman.cn">云主机活动网</a>
  </span>

  <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv"> site pv: <span id="busuanzi_value_site_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
      <span class="division">|</span>
    <span id="busuanzi_container_site_uv"> site uv: <span id="busuanzi_value_site_uv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
  </div>

  <span class="copyright-year">
    &copy; 
    2017 - 
    2019
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">LHR</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>
<script type="text/javascript" src="/dist/even.26188efa.min.js"></script>

<script id="baidu_analytics">
  var _hmt = _hmt || [];
  (function() {
    if (window.location.hostname === 'localhost') return;
    var hm = document.createElement("script"); hm.async = true;
    hm.src = "https://hm.baidu.com/hm.js?1459adbc2a99c593738e5cdc66be7fda";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();
</script>






</body>
</html>
