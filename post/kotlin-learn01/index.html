<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
<title>Kotlin基础：函数、对象、Lamdba</title>
<meta name="description"
      content=""
>

  
    
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-JLJBQBW5WM"></script>
    <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-JLJBQBW5WM');
  </script>
  




<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<link
  rel="alternate"
  type="application/rss+xml"
  href="https://chinalhr.github.io/index.xml"
  title="ChinaLHR Blog"
/>
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Kotlin基础：函数、对象、Lamdba"/>
<meta name="twitter:description" content="
Kotlin学习记录
"/>



<link rel="stylesheet" href="https://chinalhr.github.io/fontawesome/css/all.min.css" />




<link
  crossorigin="anonymous"
  href="/css/styles.min.css"
  integrity=""
  rel="preload stylesheet"
  as="style"
/>




<link
  id="dark-mode-theme"
  crossorigin="anonymous"
  href="/css/dark.min.css"
  integrity=""
  rel="preload stylesheet"
  as="style"
/>


<script>
  var darkTheme = document.getElementById('dark-mode-theme')
  var storedTheme = localStorage.getItem('dark-mode-storage')

  if (storedTheme === 'dark') {
    darkTheme.disabled = false
  } else if (storedTheme === 'light') {
    darkTheme.disabled = true
  }
</script>


<script defer crossorigin="anonymous" src="/js/theme.js" integrity=""></script>


<script defer crossorigin="anonymous" src="/js/instantpage.min.js" integrity=""></script><meta name="generator" content="Hugo 0.68.3" />
  </head>
  <body>
    
  




  <header>
    <nav class="navbar">
  <div class="nav">
    
      <a href="https://chinalhr.github.io/" class="nav-logo">
        <img
          src="https://chinalhr.github.io/images/icon.png"
          width="50"
          height="50"
          alt="Logo"
        />
      </a>
    

    <ul class="nav-links">
      
        
          <li>
            <a href="/about/" id="About"
              ><em class="fas fa-user fa-lg"></em
            ></a>
          </li>
          
      
        
          <li>
            <a href="/categories/" id="Categories"
              ><em class="fas fa-filter fa-lg"></em
            ></a>
          </li>
          
      
        
          <li>
            <a href="/tags/" id="Tags"
              ><em class="fas fa-tags fa-lg"></em
            ></a>
          </li>
          
      
        
          <li>
            <a href="/archives/" id="Archives"
              ><em class="fas fa-archive fa-lg"></em
            ></a>
          </li>
          
      
        
          <li>
            <a href="/search/" id="Search"
              ><em class="fas fa-search fa-lg"></em
            ></a>
          </li>
          
      
    </ul>
  </div>
</nav>

    <div class="intro-header">
      <div class="container">
        <div class="post-heading">
          
            <h1>
              Kotlin基础：函数、对象、Lamdba
            </h1>
          
          
            <span class="meta-post">
  <em class="fa fa-calendar-alt"></em
  >&nbsp;Jan 13, 2019
  
    &nbsp;&nbsp;&nbsp;<em class="fa fa-folder-open"></em>&nbsp;
    
      <a
        href="https://chinalhr.github.io/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"
        >后端开发</a
      >&nbsp;
    
  
</span>

          
        </div>
      </div>
    </div>
  </header>
  

    
  <div class="container" role="main">
    <article class="article" class="blog-post">
      <blockquote>
<p>Kotlin学习记录</p>
</blockquote>
<h3 id="kotlin的生态">Kotlin的生态</h3>
<ul>
<li>Android开发</li>
<li>服务端开发</li>
<li>前端开发</li>
<li>原生环境开发</li>
</ul>
<h3 id="设计哲学">设计哲学</h3>
<ul>
<li>
<p>静态类型与类型推导
所有表达式的类型在编译期已经确定了，而编译器就能验证对象是否包含了你想访问的方法或者宇段。
与Java相比(JDK8↓)，拥有型推导，不需要你在源代码中显式地声明每个变量，变量类型可 以根据上下文来自动判断的类型。</p>
</li>
<li>
<p>null安全
Kotlin 的类型系统跟踪那些可以或不可以为 null 的
值，并且禁止那些运行时可能导致 NullPointerException 的操作。(把类型标记为可空的只要在类型尾部增加一个字符?)</p>
</li>
<li>
<p>互操作性
与Java，现成库拥有极高互操作性，Kotlin的类和方法可以像常规的Java 类和方法一样被调用。(Kotlin 没有自己的集合库，它完全依赖 Java 标准库中的类)</p>
</li>
<li>
<p>没有checked exception
要求checked exception可以提高开发人员的工作效率，又可以提高代码质量，但是大型软件项目的经验表明了不同的结果-checked exception降低了生产力，代码质量很少或根本没有增加。</p>
</li>
</ul>
<p>参考：<a href="https://kotlinlang.org/docs/reference/exceptions.html">https://kotlinlang.org/docs/reference/exceptions.html</a></p>
<ul>
<li>面向表达式编程
Kotlin中的流程控制不仅是普通语句，它们可以返回值，如if表达式、when表达式、try表达式等，而且还有范围表达式(1..100),中缀表达式(a to b)。一切皆表达式的设计让开发者在设计业务时，促进了避免创造副作用的逻辑设计，从而让程序变得更加安全;而且表达式通常也具有更好的表达能力，典型的一个例子就是表达式更容易进行组合。</li>
</ul>
<h3 id="kotlin与java">Kotlin与Java</h3>
<ul>
<li>关键宇 fun 用来声明一个函数，参数的类型写在它 的名称后面</li>
<li>数组就是类,和 Java 不同， Kotlin 没有声明数组类型的特殊语法</li>
<li>在 Kotlin 中，除了循环（ for, do 和 do/while）以外大多数控制结构( if,When )都是表达式</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#960050;background-color:#1e0010">表达式与语句</span>:<span style="color:#960050;background-color:#1e0010">表达式有值，并且能作为另一个表达式的一部分使用；而语句总是包围着它的代码块中的顶层元素，并且没有自己的值。</span>

<span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">max</span>(a : Int , b: Int) = <span style="color:#66d9ef">if</span> (a &gt; b) a <span style="color:#66d9ef">else</span> b
</code></pre></div><ul>
<li>以关键字开始，然后是变量名称。(var age:Int = 20)</li>
<li>val-不可变引用,var-可变引用</li>
<li>值对象简单声明：class Person(val name: String)</li>
<li>头等属性，省略getter/setter</li>
<li>智能转换：使用 is 检查来判断一个变量是否是某种类型,Kotlin编译器检查过一个变量是某种类型，后面就不再需要转换它，可以就把它当作你检查过的类型使用。(对比Java instanceOf 之后需要显示转换)</li>
<li>when:when对比switch：switch只能使用枚举常量，字符串或者数字字面值;when 允许使用任何对象并且不需要在每个分支都写上break 语句。when是表达式且可以与if连用&hellip;.</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#75715e">//when
</span><span style="color:#75715e"></span><span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">evalWhen</span>(e: Expr): Int =
<span style="color:#66d9ef">when</span> (e) {
    <span style="color:#66d9ef">is</span> Num -&gt;
        e.value <span style="color:#75715e">//智能转换
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">is</span> Sum -&gt;
        evalWhen(e.right) + evalWhen(e.left)
    <span style="color:#66d9ef">else</span> -&gt;
        <span style="color:#66d9ef">throw</span> RuntimeException(<span style="color:#e6db74">&#34;类型错误&#34;</span>)
}
</code></pre></div><ul>
<li>
<p>for:Kotlin没有Java的for-i概念，多出来区间与数列</p>
<ul>
<li>区间</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"> <span style="color:#66d9ef">for</span> (i <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">1.</span>.<span style="color:#ae81ff">100</span>) {
     println(<span style="color:#e6db74">&#34;current：$i&#34;</span>)
 }
</code></pre></div><ul>
<li>downTo step until</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#75715e">//从100 到 1 打印偶数 步长2 向下到1
</span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span> (i <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">100</span> downTo <span style="color:#ae81ff">1</span> step <span style="color:#ae81ff">2</span>) {
    println(<span style="color:#e6db74">&#34;current：$i&#34;</span>)
}
</code></pre></div></li>
<li>
<p>异常</p>
<p>Kotlin 中 throw 结构是一个表达式，不必使用 new 关键字来创建异常实例。(try也是)
Kotlin 并不区分受检异常和未受检异常。不用指定函数抛出的异常 ， 而且可以处理也可以不处理异常。</p>
</li>
</ul>
<h3 id="函数">函数</h3>
<ul>
<li>命名参数
当调用一个 Kotlin定义的函数时，可以显式地标明一些参数的名称,避免混淆</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">joinToString(collectio, separator =<span style="color:#e6db74">&#34;&#34;</span>, prefix =<span style="color:#e6db74">&#34;&#34;</span>, postfix =<span style="color:#e6db74">&#34;·&#34;</span>)
</code></pre></div><ul>
<li>默认参数值
对比Java一些类的重载函数很多， Kotlin中可以在声明函数的时候，指定参数的默认值，这样就可以避免创建重载的函数。</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">fun</span> &lt;T&gt; <span style="color:#a6e22e">joinToString</span>(
    collection: Collection&lt;T&gt;,
    separator: String =<span style="color:#e6db74">&#34;,&#34;</span>,<span style="color:#75715e">//默认参数值
</span><span style="color:#75715e"></span>    prefix: String =<span style="color:#e6db74">&#34;&#34;</span>,
    postfix: String = <span style="color:#e6db74">&#34;&#34;</span>
    ) : String{
            
}
</code></pre></div><ul>
<li>顶层函数|参数
在Java中，类处于顶层，类包含属性和方法，在Kotlin中，函数处于顶层，我们可以直接把函数放在代码文件的顶层，让它不从属于任何类，任何类都可以调用。
目的，消除了Java中常见的静态工具类，使我们的代码更加整洁。</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">@file:JvmName(<span style="color:#e6db74">&#34;StrUtil&#34;</span>)
<span style="color:#66d9ef">package</span> util

<span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">joinToStr</span>(collection: Collection&lt;String&gt;): String{
    <span style="color:#75715e">//....
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;&#34;</span>;
}
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">import</span> util.joinToStr

<span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">main</span>(args: Array&lt;String&gt;){
    joinToStr(collection = listOf(<span style="color:#e6db74">&#34;123&#34;</span>, <span style="color:#e6db74">&#34;456&#34;</span>))
}
</code></pre></div><p>因为在Java中，类还是必须要存在的，所以编译器将Str.kt文件里的代码放在了一个自动生成的类中，然后把我们定义的Kotlin的函数作为静态方法放在其中，在Java中是先通过import导入这个类，然后通过类名.方法名来调用。可以通过@file:JvmName注解来自定义类名。</p>
<ul>
<li>扩展函数|参数</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#75715e">/**
</span><span style="color:#75715e"> * 扩展函数
</span><span style="color:#75715e"> *
</span><span style="color:#75715e"> *  String-接收者类型           get(this.length -1) 对接收者对象(字符串)进行操作并返回
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">String</span>.lastChar() : Char = <span style="color:#66d9ef">get</span>(<span style="color:#66d9ef">this</span>.length -<span style="color:#ae81ff">1</span>)

<span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">main</span>(args: Array&lt;String&gt;) {
    System.<span style="color:#66d9ef">out</span>.println(<span style="color:#e6db74">&#34;Kotlin&#34;</span>.lastChar())
}
</code></pre></div><p>导入扩展函数(Kotiin 允许用和导入类一样的语法来导入)</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">import</span> strings.lastChar
</code></pre></div><ul>
<li>to 中缀调用
infix 修饰符标识可以使用中缀调用，to 函数会返回一个 Pair 类型的对象用来表示一对元素(解构声明)</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">fun</span> &lt;K, V&gt; <span style="color:#a6e22e">mapOf</span>(<span style="color:#66d9ef">vararg</span> values: Pair&lt;K, V&gt;): Map&lt;K , V&gt;
<span style="color:#75715e">//使用
</span><span style="color:#75715e"></span>mapOf(<span style="color:#ae81ff">1</span> to <span style="color:#e6db74">&#34;One&#34;</span>,<span style="color:#ae81ff">2</span> to <span style="color:#e6db74">&#34;Two&#34;</span>)
</code></pre></div><h3 id="类-对象">类-对象</h3>
<p>Kotlin 在类名后面使用冒号来代替了 Java 中的 extends 和 implements 关键字。</p>
<ul>
<li>Java的类和方法默认是open的，而Kotlin中默认都是final的。</li>
</ul>
<p>目的：避免脆弱的基类问题(类被重写方法的风险)。Kotlin采用了open，final 和 abstract 修饰符</p>
<p>编译期强制使用override修饰符</p>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>相关成员</th>
<th>使用</th>
</tr>
</thead>
<tbody>
<tr>
<td>final</td>
<td>不能被重写</td>
<td>类中成员默认使用</td>
</tr>
<tr>
<td>open</td>
<td>可以被重写</td>
<td>需要明确地表明</td>
</tr>
<tr>
<td>abstract</td>
<td>必须被重写</td>
<td>只能在抽象类中使用：抽象成员不能有实现</td>
</tr>
<tr>
<td>override</td>
<td>重写父类或接口中的成员</td>
<td>如果没有使用 final 表明，亟写的成员默认是开放的</td>
</tr>
</tbody>
</table>
<ul>
<li>可见性修饰符：默认为 public ,模块修饰符internal</li>
</ul>
<p>internal：只在模块内部可见，一个模块就是一组一起编译的 Kotiin 文件(一个Maven或Gradle项目,IDEA模块&hellip;)</p>
<ul>
<li>Kotlin编译器生成:数据类，委托类</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#75715e">//重写toString,equals,hashCode
</span><span style="color:#75715e"></span><span style="color:#66d9ef">override</span> <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">toString</span>() = <span style="color:#e6db74">&#34;...&#34;</span>
<span style="color:#75715e">/**
</span><span style="color:#75715e"> * 数据类，编译器重写toString 、equals 和 hashCode 。 
</span><span style="color:#75715e"> * equals 用来比较实例
</span><span style="color:#75715e"> * hashCode 用来作为例如 HashMap 这种基于哈希容器的键
</span><span style="color:#75715e"> * toString 用来为类生成按声明顺序排列的所有字段的字符串表达形式
</span><span style="color:#75715e"> *  copy 方法： copy对象的同时修改某些属性的值
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">data</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Client</span>(<span style="color:#66d9ef">val</span> name: String, <span style="color:#66d9ef">val</span> postalCode: Int)
<span style="color:#75715e">/**
</span><span style="color:#75715e"> * 类委托：可以使用 by 关键字将接口的实现委托到另一个对象(避免装饰器模式带来的重复模板代码)
</span><span style="color:#75715e"> *  
</span><span style="color:#75715e"> *类相当于innerList的包装类，拥有innerList的实现，并可以覆盖原有方法提供不同实现
</span><span style="color:#75715e"> */</span>
 <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">DelegatingCollection</span>&lt;T&gt;(innerList: Collection&lt;T&gt; = ArrayList&lt;T&gt;()) : Collection&lt;T&gt; <span style="color:#66d9ef">by</span> innerList {}
</code></pre></div><ul>
<li>object关键字与伴生对象</li>
</ul>
<p>“伴生”是相较于一个类而言的，意为伴随某个类的对象，它属于这个类所有，因此伴生对象跟Java中static修饰效果性质一样，全局只有一个单例。它需要声明在类的内部，在类被装载时会被初始化。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#75715e">/**
</span><span style="color:#75715e"> * object关键字 对象声明：创建单例类
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">object</span> <span style="color:#a6e22e">Payroll</span> {
 ...
 }
 
<span style="color:#75715e">/**
</span><span style="color:#75715e"> * 伴生对象companion：工厂方法
</span><span style="color:#75715e"> */</span>
<span style="color:#75715e">//构造方法私有化
</span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">User</span> <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">constructor</span>(<span style="color:#66d9ef">val</span> nickname: String) {
    <span style="color:#75715e">//声明伴生对象:工厂方法创建对象
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">companion</span> <span style="color:#66d9ef">object</span> {
        <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">newSubscribingUser</span>(email: String) =
                User(email.substringBefore(<span style="color:#e6db74">&#34;@&#34;</span>))

        <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">newFacebookUser</span>(accountld: Int) =
                User(accountld.toString())
    }
}

<span style="color:#75715e">/**
</span><span style="color:#75715e"> * 普通类的伴生对象：伴生对象是一个声明在类中的普通对象，有名字(默认Companion )，可以实现一个接口或者有扩展函数或属性 。 伴生对象（与包级别函数和属性一起）替代了 Java 静态方法和字段定义
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Prize</span>(<span style="color:#66d9ef">val</span> name: String, <span style="color:#66d9ef">val</span> count: Int, <span style="color:#66d9ef">val</span> type: Int) {
	<span style="color:#66d9ef">companion</span> <span style="color:#66d9ef">object</span> {
		<span style="color:#66d9ef">val</span> TYPE_REDPACK = <span style="color:#ae81ff">0</span>
		<span style="color:#66d9ef">val</span> TYPE_COUPON = <span style="color:#ae81ff">1</span>
		<span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">isRedpack</span>(prize: Prize): Boolean {
			<span style="color:#66d9ef">return</span> prize.type == TYPE_REDPACK
		}
    }
 }
<span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">main</span>(args: Array&lt;String&gt;) {
	<span style="color:#66d9ef">val</span> prize = Prize(<span style="color:#e6db74">&#34;红包&#34;</span>, <span style="color:#ae81ff">10</span>, Prize.TYPE_REDPACK)
    print(Prize.isRedpack(prize))
}

<span style="color:#75715e">/**
</span><span style="color:#75715e"> * 对象表达式：(匿名内部类)
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">val</span> Listener = <span style="color:#66d9ef">object</span> <span style="color:#960050;background-color:#1e0010">: </span><span style="color:#a6e22e">MouseAdapter</span>() {
<span style="color:#66d9ef">override</span> <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">mouseClicked</span>(e: MouseEvent) { .. . }
<span style="color:#66d9ef">override</span> <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">mouseEntered</span>(e: MouseEvent) { ... }
}
</code></pre></div><ul>
<li>延迟初始化：by lazy与lateinit</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#75715e">/**
</span><span style="color:#75715e">* by lazy : val变量的初始化
</span><span style="color:#75715e">* lazy的背后是接受一个lambda并返回一个Lazy &lt;T&gt;实例的函数，第一次访问该属性时，会执行lazy对应的Lambda表达式并记录* 结果。
</span><span style="color:#75715e">* lazy属性默认LazyThreadSafetyMode.SYNCHRON IZED（同步锁）
</span><span style="color:#75715e">*/</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Bird</span>(<span style="color:#66d9ef">val</span> weight: Double, <span style="color:#66d9ef">val</span> age: Int, <span style="color:#66d9ef">val</span> color: String) {
    <span style="color:#66d9ef">val</span> sex: String <span style="color:#66d9ef">by</span> lazy {
         <span style="color:#66d9ef">if</span> (color == <span style="color:#e6db74">&#34;yellow&#34;</span>) <span style="color:#e6db74">&#34;male&#34;</span> <span style="color:#66d9ef">else</span> <span style="color:#e6db74">&#34;female&#34;</span>
	}
}

<span style="color:#75715e">/**
</span><span style="color:#75715e">* lateinit : var变量的初始化
</span><span style="color:#75715e">*/</span>
<span style="color:#66d9ef">lateinit</span> <span style="color:#66d9ef">var</span> sex: String 
<span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">printSex</span>() {
     <span style="color:#66d9ef">this</span>.sex = <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">this</span>.color == <span style="color:#e6db74">&#34;yellow&#34;</span>) <span style="color:#e6db74">&#34;male&#34;</span> <span style="color:#66d9ef">else</span> <span style="color:#e6db74">&#34;female&#34;</span>
}

<span style="color:#75715e">/**
</span><span style="color:#75715e"> * Delegates.notNull&lt;T&gt; ：基本数据类型变量初始化
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">var</span> test <span style="color:#66d9ef">by</span> Delegates.notNull&lt;Int&gt;()
<span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">doSomething</span>() {
	test = <span style="color:#ae81ff">1</span>
}
</code></pre></div><h3 id="lamdba">Lamdba</h3>
<ul>
<li>Kotlin与Java Lamdba区别
1.在Kotiin中Lamdba不会仅限于访问 final 变量，在 lambda 内部也可以修改这些变量(lambda捕捉)</li>
</ul>
<ol start="2">
<li>部分操作符增强：[kotlin]count = [java]filter + count</li>
</ol>
<ul>
<li>惰性集合操作Sequence
例如 map 和 filter操作符，每一步的中间结果都被存储在一个临时列表，Sequence可以避免创建这些临时中间对象(序列中的元素求值是惰性的)。
注意： Sequence 只提供了 一个方法， iterator
关于惰性求值：1. 惰性求值是逐个处理元素 2. 延期操作，调用末端操作(count，sum&hellip;)的时候才会求值</li>
</ul>
<p>iterator 与 Sequence 区别:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#75715e">/**
</span><span style="color:#75715e"> * 处理序列的中间操作函数是不进行任何计算的。相反，它们会返回上一个中间操作处理后产生的新序列。
</span><span style="color:#75715e"> * 所有这些一系列中间计算都将在终端操作执行中被确定，例如常见的终端操作toList或count.在另一方面，处理Iterable的每个中间操作函数都是会返回一个新的集合。
</span><span style="color:#75715e"> *
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Iterable</span>&lt;<span style="color:#66d9ef">out</span> T&gt; {
    <span style="color:#66d9ef">operator</span> <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">iterator</span>(): Iterator&lt;T&gt;
}
<span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Sequence</span>&lt;<span style="color:#66d9ef">out</span> T&gt; {
    <span style="color:#66d9ef">operator</span> <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">iterator</span>(): Iterator&lt;T&gt;
}
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#75715e">//惰性求值，避免创建临时中间对象
</span><span style="color:#75715e"></span> <span style="color:#66d9ef">val</span> list = persons.asSequence()
            .map(Person<span style="color:#f92672">::</span>name)
            .filter { it.startsWith(<span style="color:#e6db74">&#34;l&#34;</span>) }
            .toList()
<span style="color:#75715e">//惰性求值：给定序列中 的前一个元素，这个函数会计算出下一个元素。
</span><span style="color:#75715e"></span><span style="color:#66d9ef">val</span> naturalNumbers = generateSequence(<span style="color:#ae81ff">0</span>) { it + <span style="color:#ae81ff">1</span> }
println(<span style="color:#e6db74">&#34;求100 以内的和：${naturalNumbers.takeWhile { it &lt;= 100 }.sum()}&#34;</span>)
</code></pre></div><ul>
<li>with 和 apply</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#75715e">/**
</span><span style="color:#75715e"> * 使用给定的[receiver]作为接收器调用指定的函数[block]并返回其结果。
</span><span style="color:#75715e"> */</span>
@kotlin.<span style="color:#66d9ef">internal</span>.InlineOnly
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">fun</span> &lt;T, R&gt; <span style="color:#a6e22e">with</span>(receiver: T, block: T.() -&gt; R): R {
    contract {
        callsInPlace(block, InvocationKind.EXACTLY_ONCE)
    }
    <span style="color:#66d9ef">return</span> receiver.block()
}

<span style="color:#66d9ef">val</span> returnAToZ = with(StringBuilder()) {
        <span style="color:#66d9ef">for</span> (letter <span style="color:#66d9ef">in</span> <span style="color:#e6db74">&#39;A&#39;</span>..<span style="color:#e6db74">&#39;Z&#39;</span>) {
            append(letter)
        }
        toString()
}

<span style="color:#75715e">/**
</span><span style="color:#75715e"> * 使用`this`值作为接收器调用指定的函数[block]并返回`this`值。
</span><span style="color:#75715e"> */</span>
@kotlin.<span style="color:#66d9ef">internal</span>.InlineOnly
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">fun</span> &lt;T&gt; <span style="color:#a6e22e">T</span>.apply(block: T.() -&gt; Unit): T {
    contract {
        callsInPlace(block, InvocationKind.EXACTLY_ONCE)
    }
    block()
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span>
}

<span style="color:#66d9ef">val</span> returnAToZ = StringBuilder().apply {
        <span style="color:#66d9ef">for</span> (letter <span style="color:#66d9ef">in</span> <span style="color:#e6db74">&#39;A&#39;</span>..<span style="color:#e6db74">&#39;Z&#39;</span>) {
            append(letter)
        }
}
</code></pre></div><h3 id="高阶lamdba">高阶Lamdba</h3>
<ul>
<li>高阶函数</li>
</ul>
<p>一个函数返回另一个函数作为结果</p>
<pre><code>        fun foo(x: Int): (Int) -&gt; Int {
            return { y: Int -&gt; x + y }
        }
</code></pre><p>执行foo函数之后，会返回另一个类型为(Int)-&gt; Int的函数</p>
<ul>
<li>柯里化(Currying)</li>
</ul>
<p>柯里化指的是把接收多个参数的函数变换成一系列仅接收单一参数函数的过程，在返回最终结果值之前，前面的函数依次接收单个参数，然后返回下一个新的函数;柯里化是为了简化Lambda演算理论中函数接收多参数而出现的，它简化了理论，将多元函数变成了一元;</p>
<pre><code>        fun sum(x: Int) = { y: Int -&gt;
            { z: Int -&gt; x + y + z }
        }
        sum(1)(2)(3)
</code></pre><p>在kotlin中，如果参数不止一个，且最后一个参数为函数类型时，就可以采用类似柯里化风格的调用</p>
<pre><code>        fun curryingLike(content: String, block: (String) -&gt; Unit) {
            block(content)
        }
        curryingLike(&quot;looks like currying style&quot;) {
            content -&gt;
            println(content)
        }
        // 运行结果
        looks like currying style
        //也可以等值为
        curryingLike(&quot;looks like currying style&quot;,{
            content -&gt;
            println(content)
        }) 

</code></pre><ul>
<li>内联函数(消除lambda运行时开销)</li>
</ul>
<p>开销：每调用 一次 lambda 表达式，一个额外的类就会被创建。并且如果 lambda 捕捉了某个变量，那么每次调用的时候都会创建一个新的对象 。 这会带来运行时的额外开销，导致使用 lambda 比使用 一个直接执行相同代码的函数效率更低 。</p>
<p><strong>inline</strong></p>
<p>使用 inline 修饰符标记一个函数，在函数被使用的时候编译器并不会生成函数调用的代码，而是使用函数实现的真实代码替换每一次的函数调用。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">@kotlin.<span style="color:#66d9ef">internal</span>.InlineOnly
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">fun</span> &lt;T&gt; <span style="color:#a6e22e">Lock</span>.withLock(action: () -&gt; T): T {
    lock()
    <span style="color:#66d9ef">try</span> {
        <span style="color:#66d9ef">return</span> action()
    } <span style="color:#66d9ef">finally</span> {
        unlock()
    }
}
</code></pre></div><p><strong>内联函数的限制</strong>：</p>
<p>作为参数的 lambda表达式的函数体会被直接替换到最终生成的代码中。如果（lambda）参数在某个地方被保存起来，lambda 表达式的代码将不能被内联。如果（lambda）参数被调用，这
样的代码能被容易地内联。</p>
<p><strong>JVM优化</strong>
对于普通的函数调用，JVM己经提供了强大的内联支持。在将宇节码转换成机器代码时自动完成内联。使用inline 关键字只能提高带有 lambda 参数的函数的性能。将带有 lambda 参数的函数内联，节约了为 lambda 创建匿名类，以及创建 lambda 实例对象的开销。</p>
<ul>
<li>函数中的控制流</li>
</ul>
<p>lambda 中使用 return 关键字，是非局部返回(从调用 lambda 的函数中返回，并不只是从 lambda 中返回 )。只有在以 lambda 作为 参数的函数是内联函数的时候才能从更外层的函数返回。</p>
<p><strong>标签返回</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#75715e">/**
</span><span style="color:#75715e">* tag@标签：return 会跳转到引用的标签lamdba 而不会跳出整个函数
</span><span style="color:#75715e">*/</span>
<span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">lookForAlice</span>(s:List&lt;String&gt;){
   s.forEach tag<span style="color:#960050;background-color:#1e0010">@</span>{
       <span style="color:#66d9ef">if</span> (it == <span style="color:#e6db74">&#34;Alice&#34;</span>) <span style="color:#66d9ef">return</span>@tag
   }
   println(<span style="color:#e6db74">&#34;I find Alice&#34;</span>)
}
</code></pre></div><p><strong>匿名函数：默认使用局部返回</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#75715e">/**
</span><span style="color:#75715e"> * 使用匿名函数lambda
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">lookForAlice2</span>(s:List&lt;String&gt;){
    s.forEach(<span style="color:#66d9ef">fun</span> <span style="color:#960050;background-color:#1e0010">(</span><span style="color:#a6e22e">s</span>){
        <span style="color:#75715e">//return指向最近的匿名函数
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (s == <span style="color:#e6db74">&#34;Alice&#34;</span>) <span style="color:#66d9ef">return</span>
    })
    println(<span style="color:#e6db74">&#34;I find Alice&#34;</span>)
}
</code></pre></div><h3 id="字符串">字符串</h3>
<ul>
<li>原生字符串</li>
</ul>
<p>Kotlin中支持原生字符串的语法，用这种3个引号定义的字符串，最终的打印格式与在代码中所呈现的格式一致，而不会解释转化转义字符</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">        <span style="color:#66d9ef">val</span> html = <span style="color:#e6db74">&#34;&#34;&#34;&lt;html&gt;
</span><span style="color:#e6db74">                        &lt;body&gt;
</span><span style="color:#e6db74">                            &lt;p&gt;Hello World.&lt;/p&gt;
</span><span style="color:#e6db74">                        &lt;/body&gt;
</span><span style="color:#e6db74">                    &lt;/html&gt;
</span><span style="color:#e6db74">                &#34;&#34;&#34;</span>
</code></pre></div><ul>
<li>字符串模板</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">message</span>(name: String, lang: String) = <span style="color:#e6db74">&#34;Hi ${name}, welcome to ${lang}! &#34;</span>
&gt;&gt;&gt; message(<span style="color:#e6db74">&#34;Shaw&#34;</span>, <span style="color:#e6db74">&#34;Kotlin&#34;</span>)
Hi Shaw, welcome to Kotlin!
</code></pre></div>


      
        <div class="blog-tags">
          
            <a
              href="https://chinalhr.github.io/tags/kotlin/"
              >Kotlin</a
            >&nbsp;
          
        </div>
      
    </article>
    
      <button onclick="topFunction()" id="backtotopButton">
        <em class="fa fa-angle-up"></em>
      </button>
      <script>
  var backtotopButton = document.getElementById('backtotopButton')

  document.addEventListener('scroll', function () {
    if (
      document.body.scrollTop > 50 ||
      document.documentElement.scrollTop > 50
    ) {
      backtotopButton.style.opacity = '1'
    } else {
      backtotopButton.style.opacity = '0'
    }
  })

  function topFunction() {
    document.body.scrollTop = 0 
    document.documentElement.scrollTop = 0 
  }

  
  document.dispatchEvent(new CustomEvent('scroll'))
  backtotopButton.style.display = 'block'
</script>

    
    
      

    
  </div>

    <footer>
  

<div class="social-icons">
  
    
    
      
      <a href="https://github.com/chinalhr" name="GitHub">
        <em class="fab fa-github"></em>
      </a>
    
       &nbsp;&ndash;&nbsp;
      <a href="mailto:13435500980@163.com" name="Email">
        <em class="fas fa-envelope"></em>
      </a>
    
  

  
</div>


  
  <div class="container">
    <p class="credits copyright">
      <a href="https://chinalhr.github.io/about">hanrong.li</a>
      &nbsp;&copy;
      2022
      
        &nbsp;/&nbsp;
        <a href="https://chinalhr.github.io/">ChinaLHR Blog</a>
      
      &nbsp;&ndash;&nbsp;
      <em class="fas fa-moon" id="dark-mode-toggle"></em>
    </p>

    <p class="credits theme-by">
      Powered By <a href="https://gohugo.io">Hugo</a>&nbsp;
      Theme
      <a href="https://github.com/matsuyoshi30/harbor">Harbor</a>
    </p>
  </div>
</footer>

  </body>
</html>
