<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
<title>Vertx Kotlin协程</title>


  
    
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-JLJBQBW5WM"></script>
    <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-JLJBQBW5WM');
  </script>
  




<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<link
  rel="alternate"
  type="application/rss+xml"
  href="https://chinalhr.github.io/index.xml"
  title="ChinaLHR Blog"
/>
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Vertx Kotlin协程"/>
<meta name="twitter:description" content="
Vert.x 利用 Kotlin协程特性优雅编写异步逻辑
"/>



<link rel="stylesheet" href="https://chinalhr.github.io/fontawesome/css/all.min.css" />




<link
  crossorigin="anonymous"
  href="/css/styles.min.css"
  integrity=""
  rel="preload stylesheet"
  as="style"
/>




<link
  id="dark-mode-theme"
  crossorigin="anonymous"
  href="/css/dark.min.css"
  integrity=""
  rel="preload stylesheet"
  as="style"
/>


<script>
  var darkTheme = document.getElementById('dark-mode-theme')
  var storedTheme = localStorage.getItem('dark-mode-storage')

  if (storedTheme === 'dark') {
    darkTheme.disabled = false
  } else if (storedTheme === 'light') {
    darkTheme.disabled = true
  }
</script>


<script defer crossorigin="anonymous" src="/js/theme.js" integrity=""></script>


<script defer crossorigin="anonymous" src="/js/instantpage.min.js" integrity=""></script><meta name="generator" content="Hugo 0.68.3" />
  </head>
  <body>
    
  




  <header>
    <nav class="navbar">
  <div class="nav">
    
      <a href="https://chinalhr.github.io/" class="nav-logo">
        <img
          src="https://chinalhr.github.io/images/icon.png"
          width="50"
          height="50"
          alt="Logo"
        />
      </a>
    

    <ul class="nav-links">
      
        
          <li>
            <a href="/about/" id="About"
              ><em class="fas fa-user fa-lg"></em
            ></a>
          </li>
          
      
        
          <li>
            <a href="/categories/" id="Categories"
              ><em class="fas fa-filter fa-lg"></em
            ></a>
          </li>
          
      
        
          <li>
            <a href="/tags/" id="Tags"
              ><em class="fas fa-tags fa-lg"></em
            ></a>
          </li>
          
      
        
          <li>
            <a href="/archives/" id="Archives"
              ><em class="fas fa-archive fa-lg"></em
            ></a>
          </li>
          
      
        
          <li>
            <a href="/search/" id="Search"
              ><em class="fas fa-search fa-lg"></em
            ></a>
          </li>
          
      
    </ul>
  </div>
</nav>

    <div class="intro-header">
      <div class="container">
        <div class="post-heading">
          
            <h1>
              Vertx Kotlin协程
            </h1>
          
          
            <span class="meta-post">
  <em class="fa fa-calendar-alt"></em
  >&nbsp;May 23, 2019
  
    &nbsp;&nbsp;&nbsp;<em class="fa fa-folder-open"></em>&nbsp;
    
      <a
        href="https://chinalhr.github.io/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"
        >后端开发</a
      >&nbsp;
    
  
</span>

          
        </div>
      </div>
    </div>
  </header>
  

    
  <div class="container" role="main">
    <article class="article" class="blog-post">
      <blockquote>
<p>Vert.x 利用 Kotlin协程特性优雅编写异步逻辑</p>
</blockquote>
<h3 id="关于协程">关于协程</h3>
<p>协程通过将复杂性放入库来简化异步编程。程序的逻辑可以在协程中顺序地表达，而底层库会为我们解决其异步性。使用协程库将用户代码的相关部分包装为回调、订阅相关事件、在不同线程（甚至不同机器）上调度执行，而代码则保持如同顺序执行一样简单。</p>
<p>轻量级的线程。线程是由系统调度的，线程切换或线程阻塞的开销都比较大。而协程依赖于线程，但是协程挂起时不需要阻塞线程，几乎是无代价的，协程是由开发者控制的。所以协程也像用户态的线程，非常轻量级，一个线程中可以创建任意个协程。</p>
<h3 id="kotlin协程">Kotlin协程</h3>
<ul>
<li>suspend</li>
</ul>
<p>suspend修饰符标记，修饰挂起函数。挂起函数能够以与普通函数相同的方式获取参数和返回值，但是调用函数可能挂起协程（如果相关调用的结果已经可用，库可以决定继续进行而不挂起），挂起函数挂起协程时，不会阻塞协程所在的线程。挂起函数执行完成后会恢复协程，后面的代码才会继续执行。</p>
<p>挂起函数只能在协程中或其他挂起函数中调用(launch函数创建协程)</p>
<ul>
<li>CoroutineScope</li>
</ul>
<p>协程本身</p>
<ul>
<li>CoroutineContext</li>
</ul>
<p>协程上下文，包括 Job 和 CoroutineDispatcher 元素，可以代表一个协程的场景。</p>
<ul>
<li>CoroutineDispatcher</li>
</ul>
<p>协程调度器，决定协程所在的线程或线程池。标准实现Dispatchers.Default、Dispatchers.IO，Dispatchers.Main和Dispatchers.Unconfined</p>
<pre><code>- Default一般用于 CPU 密集型的任务,特别是涉及到计算、算法的场景。它可以使用和 CPU 核数一样多的线程。
- IO一般用于输入/输出的场景。通常，涉及到会阻塞线程，需要等待另一个系统响应的任务，比如：网络请求、数据库操作、文件读写等，都可以使用它。因为它不使用 CPU ，可以同一时间运行多个线程，默认是数量为 64 的线程池。
- Main使用UI线程/主线程
- UnConfined不指定线程，使用的线程是不可控的
</code></pre>
<ul>
<li>Coroutine builders</li>
</ul>
<p>协程构建器</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#75715e">//launch不阻塞当前线程，在后台创建一个新协程
</span><span style="color:#75715e">//context 指定调度器 start 启动模式[CoroutineStart.DEAFAULT,LAZY(延迟启动)]
</span><span style="color:#75715e"></span> GlobalScope.launch(Dispatchers.Main) {
    <span style="color:#75715e">//suspend fun
</span><span style="color:#75715e"></span> }
 
 <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">main</span>() {
        <span style="color:#66d9ef">val</span> job = GlobalScope.launch(start = CoroutineStart.LAZY) {
            println(<span style="color:#e6db74">&#34;World!&#34;</span>)
        }
        println(<span style="color:#e6db74">&#34;Hello,&#34;</span>)
        job.start()
        Thread.sleep(<span style="color:#ae81ff">2000L</span>)
    }

<span style="color:#75715e">//runBlocking {}是创建一个新的协程同时阻塞当前线程
</span><span style="color:#75715e"></span>runBlocking {
      launch { 
        <span style="color:#75715e">//suspend fun
</span><span style="color:#75715e"></span>    }
}

<span style="color:#75715e">//withContext不会创建新的协程，在指定协程上运行挂起代码块，并挂起该协程直至代码块运行完成
</span><span style="color:#75715e"></span>withContext {}

<span style="color:#75715e">//async和launch 一个效果，但是有返回值
</span><span style="color:#75715e"></span>CoroutineScope.async {}
</code></pre></div><ul>
<li>Job &amp; Deferred</li>
</ul>
<p>launch 方法会返回一个 Job，Job 继承了协程上下文（CoroutineContext）。</p>
<p>async方法返回一个Deferred 允许并行地运行多个子线程任务，它不是一个可中断方法，所以当调用 async 启动子协程的同时，后面的代码也会立即执行。async 通常需要运行在另外一个协程内部，它会返回一个特殊的 Job，叫作 Deferred。</p>
<p>Job没有返回值，Deferred有返回值。一个Job可以有一个父Job，父Job可以控制子Job。</p>
<p>Job封装了协程中需要执行的代码逻辑。生命周期如下:</p>
<p><img src="https://user-images.githubusercontent.com/19829495/58104450-64475800-7c17-11e9-8ed4-cc54edbc9e59.png" alt="enter description here"></p>
<p><strong>Job相关方法</strong>：</p>
<pre><code>- job.join(中断与当前 Job 关联的协程，直到所有子 Job 执行完成)
- job.cancel(取消所有与其关联的子 Job)
</code></pre>
<p><strong>Deferred方法</strong>
- await(当我们需要获取 async 的结果时，需要调用 await() 方法等待结果。调用 await() 方法后，会中断当前协程，直到其返回结果)</p>
<h3 id="vertx-使用协程避免callback-hell">Vertx 使用协程避免Callback Hell</h3>
<p>vert.x的非阻塞特性导致需要编写非阻塞API。vert.x的核心API使用回调函数的风格，也可以使用发布-订阅模型的RxJava。异步的API编程比同步的更复杂更容易出错，而且不可避免
Callback Hell。</p>
<p>使用vertx-lang-kotlin-coroutines，编写同步风格的异步代码</p>
<p><a href="https://github.com/ChinaLHR/vertx-kotlin-scaffold.git">示例</a></p>


      
        <div class="blog-tags">
          
            <a
              href="https://chinalhr.github.io/tags/vert.x/"
              >Vert.x</a
            >&nbsp;
          
        </div>
      
    </article>
    
      <script>
  document.addEventListener('scroll', function () {
    if (
      document.body.scrollTop > 50 ||
      document.documentElement.scrollTop > 50
    ) {
      document.getElementById('backtotopButton').style.opacity = '1'
      document.getElementById('backtotopButton').style.transition = '0.5s'
    } else {
      document.getElementById('backtotopButton').style.opacity = '0'
      document.getElementById('backtotopButton').style.transition = '0.5s'
    }
  })

  function topFunction() {
    document.body.scrollTop = 0 
    document.documentElement.scrollTop = 0 
  }
</script>

      <button onclick="topFunction()" id="backtotopButton">
        <em class="fa fa-angle-up"></em>
      </button>
    
    
      

    
  </div>

    <footer>
  

<div class="social-icons">
  
    
    
      
      <a href="https://github.com/chinalhr" name="GitHub">
        <em class="fab fa-github"></em>
      </a>
    
       &nbsp;&ndash;&nbsp;
      <a href="mailto:13435500980@163.com" name="Email">
        <em class="fas fa-envelope"></em>
      </a>
    
  

  
</div>


  
  <div class="container">
    <p class="credits copyright">
      <a href="https://chinalhr.github.io/about">hanrong.li</a>
      &nbsp;&copy;
      2022
      
        &nbsp;/&nbsp;
        <a href="https://chinalhr.github.io/">ChinaLHR Blog</a>
      
      &nbsp;&ndash;&nbsp;
      <em class="fas fa-moon" id="dark-mode-toggle"></em>
    </p>

    <p class="credits theme-by">
      Powered By <a href="https://gohugo.io">Hugo</a>&nbsp;
      Theme
      <a href="https://github.com/matsuyoshi30/harbor">Harbor</a>
    </p>
  </div>
</footer>

  </body>
</html>
