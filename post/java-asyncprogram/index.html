<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
<title>Java技术域中的异步编程</title>
<meta name="description"
      content=""
>

  
    
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-JLJBQBW5WM"></script>
    <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-JLJBQBW5WM');
  </script>
  




<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<link
  rel="alternate"
  type="application/rss+xml"
  href="https://chinalhr.github.io/index.xml"
  title="ChinaLHR Blog"
/>
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Java技术域中的异步编程"/>
<meta name="twitter:description" content="
Java技术域异步编程总结
"/>



<link rel="stylesheet" href="https://chinalhr.github.io/fontawesome/css/all.min.css" />




<link
  crossorigin="anonymous"
  href="/css/styles.min.css"
  integrity=""
  rel="preload stylesheet"
  as="style"
/>




<link
  id="dark-mode-theme"
  crossorigin="anonymous"
  href="/css/dark.min.css"
  integrity=""
  rel="preload stylesheet"
  as="style"
/>


<script>
  var darkTheme = document.getElementById('dark-mode-theme')
  var storedTheme = localStorage.getItem('dark-mode-storage')

  if (storedTheme === 'dark') {
    darkTheme.disabled = false
  } else if (storedTheme === 'light') {
    darkTheme.disabled = true
  }
</script>


<script defer crossorigin="anonymous" src="/js/theme.js" integrity=""></script>


<script defer crossorigin="anonymous" src="/js/instantpage.min.js" integrity=""></script><meta name="generator" content="Hugo 0.68.3" />
  </head>
  <body>
    
  




  <header>
    <nav class="navbar">
  <div class="nav">
    
      <a href="https://chinalhr.github.io/" class="nav-logo">
        <img
          src="https://chinalhr.github.io/images/icon.png"
          width="50"
          height="50"
          alt="Logo"
        />
      </a>
    

    <ul class="nav-links">
      
        
          <li>
            <a href="/about/" id="About"
              ><em class="fas fa-user fa-lg"></em
            ></a>
          </li>
          
      
        
          <li>
            <a href="/categories/" id="Categories"
              ><em class="fas fa-filter fa-lg"></em
            ></a>
          </li>
          
      
        
          <li>
            <a href="/tags/" id="Tags"
              ><em class="fas fa-tags fa-lg"></em
            ></a>
          </li>
          
      
        
          <li>
            <a href="/archives/" id="Archives"
              ><em class="fas fa-archive fa-lg"></em
            ></a>
          </li>
          
      
        
          <li>
            <a href="/search/" id="Search"
              ><em class="fas fa-search fa-lg"></em
            ></a>
          </li>
          
      
    </ul>
  </div>
</nav>

    <div class="intro-header">
      <div class="container">
        <div class="post-heading">
          
            <h1>
              Java技术域中的异步编程
            </h1>
          
          
            <span class="meta-post">
  <em class="fa fa-calendar-alt"></em
  >&nbsp;Apr 3, 2020
  
    &nbsp;&nbsp;&nbsp;<em class="fa fa-folder-open"></em>&nbsp;
    
      <a
        href="https://chinalhr.github.io/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"
        >后端开发</a
      >&nbsp;
    
  
</span>

          
        </div>
      </div>
    </div>
  </header>
  

    
  <div class="container" role="main">
    <article class="article" class="blog-post">
      <blockquote>
<p>Java技术域异步编程总结</p>
</blockquote>
<nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#异步编程优势">异步编程优势</a></li>
        <li><a href="#java异步编程技术实现方式">Java异步编程技术实现方式</a>
          <ul>
            <li><a href="#线程池">线程池</a>
              <ul>
                <li><a href="#核心理念">核心理念</a></li>
                <li><a href="#线程池构造">线程池构造</a></li>
                <li><a href="#线程池投递任务原理简述">线程池投递任务原理简述</a></li>
                <li><a href="#线程池关闭">线程池关闭</a></li>
                <li><a href="#总结">总结</a></li>
              </ul>
            </li>
            <li><a href="#jdk的future">JDK的Future</a>
              <ul>
                <li><a href="#futuretask">FutureTask</a></li>
                <li><a href="#futuretask构造">FutureTask构造</a></li>
                <li><a href="#futuretask执行与获取">FutureTask执行与获取</a></li>
                <li><a href="#总结-1">总结</a></li>
              </ul>
            </li>
            <li><a href="#jdk的completablefuture">JDK的CompletableFuture</a>
              <ul>
                <li><a href="#显式设置completablefuture结果">显式设置CompletableFuture结果</a></li>
                <li><a href="#异步计算与结果转换">异步计算与结果转换</a></li>
                <li><a href="#多completablefuture组合运算">多CompletableFuture组合运算</a></li>
                <li><a href="#异常处理">异常处理</a></li>
                <li><a href="#stream与completablefuture">Stream与CompletableFuture</a></li>
              </ul>
            </li>
            <li><a href="#rxjava与reactor">RxJava与Reactor</a>
              <ul>
                <li><a href="#基于rxjava实现异步编程">基于RxJava实现异步编程</a></li>
                <li><a href="#基于reactor实现异步编程">基于Reactor实现异步编程</a></li>
              </ul>
            </li>
            <li><a href="#spring的taskexecutor">Spring的TaskExecutor</a>
              <ul>
                <li><a href="#在springboot中使用taskexecutor进行异步处理">在SpringBoot中使用TaskExecutor进行异步处理</a></li>
                <li><a href="#async注解执行原理">@Async注解执行原理</a></li>
              </ul>
            </li>
            <li><a href="#servlet异步编程">Servlet异步编程</a>
              <ul>
                <li><a href="#servlet30-提供的异步处理">Servlet3.0 提供的异步处理</a></li>
                <li><a href="#servlet31-提供的非阻塞io处理">Servlet3.1 提供的非阻塞IO处理</a></li>
              </ul>
            </li>
            <li><a href="#netty">Netty</a>
              <ul>
                <li><a href="#线程模型">线程模型</a></li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav><h2 id="异步编程优势">异步编程优势</h2>
<p>异步编程是可以让程序并行运行的一种手段，其可以让程序中的一个工作单元与主应用程序线程分开独立运行，并且等工作单元运行结束后通知主应用程序线程它的运行结果或者失败原因。使用它有许多好处，例如改进的应用程序性能和减少用户等待时间等。异步编程充分利用单核CPU的性能，意在单个CPU上执行几个松耦合的任务。</p>
<p><strong>同步阻塞对比异步非阻塞</strong></p>
<p>当线程发生一次rpc调用或者http调用，又或者其他的一些耗时的IO调用，发起之后，如果是同步阻塞，这个线程就会被阻塞挂起，直到结果返回，如果IO调用很频繁的话CPU使用率其实会很低。通过异步非阻塞调用，当发生IO调用时我只需要把回调函数写入这次IO调用，我这个时候线程可以继续处理新的请求，当IO调用结束结束时，会调用回调函数，充分利用CPU资源。</p>
<p><strong>异步编程场景</strong>：</p>
<p>异步化并不是万能，异步化程序并不能缩短整个链路调用时间长的问题，而是旨在最大化提升qps，但也需要针对场景异步优化。</p>
<p>IO密集型：例如网络调用，文件传输，文件读取&hellip;，这个时候线程一般会挂起阻塞，异步编程可以针对这个场景进行优化。</p>
<p>CPU密集型：例如一些数据的聚合运算，对象的序列化，排序查找等CPU耗时任务，异步化并不能解决这个问题，需要进行一些算法的优化或者利用一些并行处理框架进行优化，充分利用多核CPU。</p>
<h2 id="java异步编程技术实现方式">Java异步编程技术实现方式</h2>
<h3 id="线程池">线程池</h3>
<p>具体使用方式如下代码所示：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">static</span> ThreadPoolExecutor POOL_EXECUTOR <span style="color:#f92672">=</span>
            <span style="color:#66d9ef">new</span> ThreadPoolExecutor<span style="color:#f92672">(</span>AVALIABLE_PROCESSORS<span style="color:#f92672">,</span> AVALIABLE_PROCESSORS <span style="color:#f92672">*</span> 2<span style="color:#f92672">,</span>
                    1<span style="color:#f92672">,</span> TimeUnit<span style="color:#f92672">.</span><span style="color:#a6e22e">MINUTES</span><span style="color:#f92672">,</span> <span style="color:#66d9ef">new</span> LinkedBlockingQueue<span style="color:#f92672">&lt;&gt;(</span>5<span style="color:#f92672">),</span>
                    <span style="color:#66d9ef">new</span> ThreadPoolExecutor<span style="color:#f92672">.</span><span style="color:#a6e22e">CallerRunsPolicy</span><span style="color:#f92672">());</span>

    <span style="color:#75715e">/**
</span><span style="color:#75715e">     * 投递任务，不获取返回值
</span><span style="color:#75715e">     */</span>
    <span style="color:#a6e22e">@Test</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">threadPoolAsyncRunnable</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        StopWatch watch <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> StopWatch<span style="color:#f92672">();</span>
        watch<span style="color:#f92672">.</span><span style="color:#a6e22e">start</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;ThreadPoolAsyncTask&#34;</span><span style="color:#f92672">);</span>
        POOL_EXECUTOR<span style="color:#f92672">.</span><span style="color:#a6e22e">execute</span><span style="color:#f92672">(()</span> <span style="color:#f92672">-&gt;</span> doSomeThing<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;task1&#34;</span><span style="color:#f92672">));</span>
        doSomeThing<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;task2&#34;</span><span style="color:#f92672">);</span>
        watch<span style="color:#f92672">.</span><span style="color:#a6e22e">stop</span><span style="color:#f92672">();</span>
        log<span style="color:#f92672">.</span><span style="color:#a6e22e">info</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;total time :{} millisecond&#34;</span><span style="color:#f92672">,</span> watch<span style="color:#f92672">.</span><span style="color:#a6e22e">getTotalTimeMillis</span><span style="color:#f92672">());</span>
    <span style="color:#f92672">}</span>

    <span style="color:#75715e">/**
</span><span style="color:#75715e">     * 投递任务，同步获取
</span><span style="color:#75715e">     */</span>
    <span style="color:#a6e22e">@Test</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">threadPoolAsyncSubmit</span><span style="color:#f92672">()</span> <span style="color:#66d9ef">throws</span> ExecutionException<span style="color:#f92672">,</span> InterruptedException <span style="color:#f92672">{</span>
        StopWatch watch <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> StopWatch<span style="color:#f92672">();</span>
        watch<span style="color:#f92672">.</span><span style="color:#a6e22e">start</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;ThreadPoolAsyncTask&#34;</span><span style="color:#f92672">);</span>
        Future<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> resultFuture <span style="color:#f92672">=</span> POOL_EXECUTOR<span style="color:#f92672">.</span><span style="color:#a6e22e">submit</span><span style="color:#f92672">(()</span> <span style="color:#f92672">-&gt;</span> doSomeThing<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;task1&#34;</span><span style="color:#f92672">));</span>
        doSomeThing<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;task2&#34;</span><span style="color:#f92672">);</span>
        <span style="color:#75715e">//同步等待结果
</span><span style="color:#75715e"></span>        String result <span style="color:#f92672">=</span> resultFuture<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">();</span>
        watch<span style="color:#f92672">.</span><span style="color:#a6e22e">stop</span><span style="color:#f92672">();</span>
        log<span style="color:#f92672">.</span><span style="color:#a6e22e">info</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;total time :{} millisecond&#34;</span><span style="color:#f92672">,</span> watch<span style="color:#f92672">.</span><span style="color:#a6e22e">getTotalTimeMillis</span><span style="color:#f92672">());</span>
    <span style="color:#f92672">}</span>
</code></pre></div><h4 id="核心理念">核心理念</h4>
<p>使用线程来进行异步执行，避免阻塞当前线程，利用线程池来实现线程的复用。</p>
<h4 id="线程池构造">线程池构造</h4>
<p><img src="https://user-images.githubusercontent.com/19829495/77933072-fc56a900-72e0-11ea-9d2f-737766995464.png" alt="图片"></p>
<ul>
<li>ctl：是Integer的原子变量，同时记录线程池状态和线程池中线程个数</li>
</ul>
<pre><code>- 线程池状态
RUNNING：接收新任务并且处理阻塞队列里的任务
SHUTDOWN：拒绝新任务但是处理阻塞队列里的任务
STOP：拒绝新任务并且抛弃阻塞队列里的任务，同时中断正在处理的任务
TIDYING：所有任务都执行完（包含阻塞队列里面任务），当前线程池活动线程为0，将要调用terminated方法
TERMINATED：终止状态。terminated方法调用完成以后的状态

- 状态转换
显式调用shutdown()方法或者隐式调用了finalize()：RUNNING→SHUTDOWN
显式调用shutdownNow()方法：RUNNING或者SHUTDOWN→STOP
当线程池和任务队列都为空时：SHUTDOWN→TIDYING
当线程池为空时：STOP→TIDYING
当terminated() hook方法执行完成时：TIDYING→TERMINATED
</code></pre><ul>
<li>corePoolSize：线程池核心线程个数</li>
<li>workQueue：用于保存等待执行的任务的阻塞队列</li>
<li>maximunPoolSize：线程池最大线程数量</li>
<li>threadFactory：创建线程的工厂类</li>
<li>defaultHandler：饱和策略，当队列满了并且线程个数达到maximunPoolSize后采取的策略，比如AbortPolicy（抛出异常）、CallerRunsPolicy（使用调用者所在线程来运行任务）、DiscardOldestPolicy（调用poll丢弃一个任务，执行当前任务）、DiscardPolicy（默默丢弃，不抛出异常）</li>
<li>keeyAliveTime：存活时间。如果当前线程池中的线程数量比核心线程数量要多，并且是闲置状态的话，这些闲置的线程能存活的最大时间。</li>
</ul>
<h4 id="线程池投递任务原理简述">线程池投递任务原理简述</h4>
<p><img src="https://user-images.githubusercontent.com/19829495/77933986-075e0900-72e2-11ea-9a19-fa34e0ac544e.png" alt="图片"></p>
<ul>
<li>execute</li>
</ul>
<p>大致流程如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">execute</span><span style="color:#f92672">(</span>Runnable command<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
<span style="color:#f92672">...</span>

            <span style="color:#75715e">//1. 获取当前线程池的状态+线程个数变量的组合值
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">int</span> c <span style="color:#f92672">=</span> ctl<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">();</span>

            <span style="color:#75715e">//2. 当前线程池线程个数是否小于corePoolSize，小于则开启新线程运行
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>workerCountOf<span style="color:#f92672">(</span>c<span style="color:#f92672">)</span> <span style="color:#f92672">&lt;</span> corePoolSize<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>addWorker<span style="color:#f92672">(</span>command<span style="color:#f92672">,</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">))</span>
                    <span style="color:#66d9ef">return</span><span style="color:#f92672">;</span>
                c <span style="color:#f92672">=</span> ctl<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">();</span>
            <span style="color:#f92672">}</span>
        	<span style="color:#75715e">//3. 如果线程池处于RUNNING状态，则添加任务到阻塞队列
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>isRunning<span style="color:#f92672">(</span>c<span style="color:#f92672">)</span> <span style="color:#f92672">&amp;&amp;</span> workQueue<span style="color:#f92672">.</span><span style="color:#a6e22e">offer</span><span style="color:#f92672">(</span>command<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>

            <span style="color:#75715e">//3.1 二次检查
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">int</span> recheck <span style="color:#f92672">=</span> ctl<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">();</span>
            <span style="color:#75715e">//3.2 如果当前线程池状态不是RUNNING则从队列删除任务，并执行拒绝策略
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span> isRunning<span style="color:#f92672">(</span>recheck<span style="color:#f92672">)</span> <span style="color:#f92672">&amp;&amp;</span> remove<span style="color:#f92672">(</span>command<span style="color:#f92672">))</span>
                reject<span style="color:#f92672">(</span>command<span style="color:#f92672">);</span>

            <span style="color:#75715e">//3.3 如果当前线程池线程为空，则添加一个线程
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>workerCountOf<span style="color:#f92672">(</span>recheck<span style="color:#f92672">)</span> <span style="color:#f92672">==</span> 0<span style="color:#f92672">)</span>
                addWorker<span style="color:#f92672">(</span><span style="color:#66d9ef">null</span><span style="color:#f92672">,</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
        <span style="color:#75715e">//4. 如果队列满了，则新增线程执行，如果当前线程池的线程个数大于maximumPoolSize执行拒绝策略
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span> addWorker<span style="color:#f92672">(</span>command<span style="color:#f92672">,</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">))</span>
            reject<span style="color:#f92672">(</span>command<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>

</code></pre></div><ul>
<li>submit</li>
</ul>
<p>submit会将Runnable包装成RunnableFuture后，调用execute投递到线程池执行</p>
<ul>
<li>worker</li>
</ul>
<p>上述addWorker方法执行后，用户线程会马上返回，任务稍后再由Worker线程执行。Worker本身实现了Runnable方法，具体如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
	runWorker<span style="color:#f92672">(</span><span style="color:#66d9ef">this</span><span style="color:#f92672">);</span> <span style="color:#75715e">//委托给runWorker方法
</span><span style="color:#75715e"></span><span style="color:#f92672">}</span>
</code></pre></div><p>worker的runWorker方法会获取线程进行任务执行，并且会执行调用前后的钩子方法。</p>
<h4 id="线程池关闭">线程池关闭</h4>
<p><img src="https://user-images.githubusercontent.com/19829495/77934977-696b3e00-72e3-11ea-8eb7-62f4dfc0a0c1.png" alt="图片"></p>
<h4 id="总结">总结</h4>
<p>虽然线程池方式提供了线程复用可以获取任务返回值，但是获取返回值时还是需要阻塞调用线程的。</p>
<h3 id="jdk的future">JDK的Future</h3>
<p>JUC包中Future可以用于异步计算，Future中提供了一系列方法用来检查计算结果是否已经完成，同步等待任务执行完成，获取计算结果。</p>
<p><img src="https://user-images.githubusercontent.com/19829495/77935728-6ae93600-72e4-11ea-95f2-5745d38d29cc.png" alt="图片"></p>
<h4 id="futuretask">FutureTask</h4>
<p>FutureTask实现了Future接口，接受的任务可以是Callable类型，也可以是Runnable类型，一般被提交到线程池中进行异步执行，最后调用get系列方法阻塞获取。具体使用方式如下代码所示：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"> 		<span style="color:#75715e">//异步执行task1
</span><span style="color:#75715e"></span>        FutureTask<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> task <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> FutureTask<span style="color:#f92672">&lt;&gt;(()</span> <span style="color:#f92672">-&gt;</span> doSomeThing<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;task1&#34;</span><span style="color:#f92672">));</span>
        POOL_EXECUTOR<span style="color:#f92672">.</span><span style="color:#a6e22e">execute</span><span style="color:#f92672">(</span>task<span style="color:#f92672">);</span>

        <span style="color:#75715e">//同步执行task2
</span><span style="color:#75715e"></span>        String result2 <span style="color:#f92672">=</span> doSomeThing<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;task2&#34;</span><span style="color:#f92672">);</span>
        <span style="color:#75715e">//同步等待task1
</span><span style="color:#75715e"></span>        String result1 <span style="color:#f92672">=</span> task<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">();</span>
</code></pre></div><h4 id="futuretask构造">FutureTask构造</h4>
<p><img src="https://user-images.githubusercontent.com/19829495/78034971-0d63f080-739b-11ea-86b0-49026627bea0.png" alt="图片"></p>
<ul>
<li>state：用来记录任务的状态</li>
</ul>
<pre><code>private static final int NEW           = 0;		//新建
private static final int COMPLETING    = 1;		//完成中...
private static final int NORMAL        = 2;		//正常
private static final int EXCEPTIONAL   = 3;		//异常
private static final int CANCELLED     = 4;		//取消
private static final int INTERRUPTING  = 5;		//中断中...
private static final int INTERRUPTED   = 6;		//中断

- 状态转换
NEW→COMPLETING→NORMAL：正常终止流程转换
NEW→COMPLETING→EXCEPTIONAL：执行过程中发生异常流程转换
NEW→CANCELLED：任务还没开始就被取消
NEW→INTERRUPTING→INTERRUPTED：任务被中断
</code></pre><ul>
<li>outcome：任务运行的结果</li>
<li>runner：记录运行该任务的线程</li>
<li>waiters：链表，记录等待任务结果的线程</li>
</ul>
<h4 id="futuretask执行与获取">FutureTask执行与获取</h4>
<ul>
<li>run</li>
</ul>
<p>当创建一个FutureTask时，其任务状态初始化为NEW，提交到线程或者线程池后，会有一个线程来执行该FutureTask任务，通过调用FutureTask的run()执行。run()方法判断并且设置state状态，调用call执行任务，当任务执行完毕后会把结果或者异常信息设置到outcome变量，最后遍历激活waiters链表中所有由于等待获取结果而被阻塞的线程（LockSupport.unpark()），并从waiters链表中移除它们。</p>
<ul>
<li>get</li>
</ul>
<p>在其他线程调用FutureTask的get()方法来等待获取结果，get()方法会判断任务状态是否小于等于COMPLETING，是则阻塞线程循环等待任务完成，加入waiters链表，调用LockSupport.park()挂起线程，如果任务状态为COMPLETING（正在执行），调用Thread.yield()进行线程让步。当线程被激活时，会去获取outcome变量拿到结果。</p>
<h4 id="总结-1">总结</h4>
<p>FutureTask虽然提供了用来检查任务是否执行完成、等待任务执行结果、获取任务执行结果的方法，但是它并不能清楚地表达多个FutureTask之间的关系。而且从Future获取结果需要调用get()方法，该方法会在任务执行完毕前阻塞调用线程。</p>
<h3 id="jdk的completablefuture">JDK的CompletableFuture</h3>
<p>CompletableFuture是一个可以通过编程方式显式地设置计算结果和状态以便让任务结束的Future，并且其可以作为一个CompletionStage（计算阶段），当它的计算完成时可以触发一个函数或者行为；当多个线程企图调用同一个CompletableFuture的complete、cancel方式时只有一个线程会成功。</p>
<p>CompletableFuture所有异步的方法在没有显式指定Executor参数的情形下都是复ForkJoinPool的commonPool()线程池来执行。</p>
<p>CompletableFuture基于栈收集任务，所以在同一个CompletableFuture对象上行为注册的顺序与行为执行的顺序是相反的。</p>
<h4 id="显式设置completablefuture结果">显式设置CompletableFuture结果</h4>
<p>通过编程显式设置结果的future（complete），阻塞获取结果（get）。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">CompletableFuture<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> future <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> CompletableFuture<span style="color:#f92672">&lt;&gt;();</span>
        POOL_EXECUTOR<span style="color:#f92672">.</span><span style="color:#a6e22e">execute</span><span style="color:#f92672">(()-&gt;{</span>
            String result <span style="color:#f92672">=</span> doSomeThing<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;task1&#34;</span><span style="color:#f92672">);</span>
            <span style="color:#75715e">//显式设置
</span><span style="color:#75715e"></span>            future<span style="color:#f92672">.</span><span style="color:#a6e22e">complete</span><span style="color:#f92672">(</span>result<span style="color:#f92672">);</span>
        <span style="color:#f92672">});</span>
        <span style="color:#75715e">//阻塞获取
</span><span style="color:#75715e"></span>log<span style="color:#f92672">.</span><span style="color:#a6e22e">info</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;result:{}&#34;</span><span style="color:#f92672">,</span>future<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">());</span>
</code></pre></div><h4 id="异步计算与结果转换">异步计算与结果转换</h4>
<p><strong>方法命名规律</strong>：以run为例子，不以Async结尾的方法由原来的线程计算，以Async结尾的方法由默认的线程池ForkJoinPool.commonPool()或者指定的线程池executor运行。</p>
<p><strong>runAsync</strong>：无返回值的异步计算</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">static</span> CompletableFuture<span style="color:#f92672">&lt;</span>Void<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">runAsync</span><span style="color:#f92672">(</span>Runnable runnable<span style="color:#f92672">,</span>Executor executor<span style="color:#f92672">)</span>
</code></pre></div><p><strong>supplyAsync</strong>：带有返回值的异步计算，可以通过get方法获取返回值</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">static</span> <span style="color:#f92672">&lt;</span>U<span style="color:#f92672">&gt;</span> CompletableFuture<span style="color:#f92672">&lt;</span>U<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">supplyAsync</span><span style="color:#f92672">(</span>Supplier<span style="color:#f92672">&lt;</span>U<span style="color:#f92672">&gt;</span> supplier<span style="color:#f92672">,</span>Executor executor<span style="color:#f92672">)</span>
</code></pre></div><p><strong>thenRunAsync</strong>：执行完成任务后，激活其他任务（其他任务拿不到之前任务的返回值）</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"> CompletableFuture<span style="color:#f92672">&lt;</span>Void<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">thenRunAsync</span><span style="color:#f92672">(</span>Runnable action<span style="color:#f92672">,</span>Executor executor<span style="color:#f92672">)</span>
</code></pre></div><p><strong>thenAcceptAsync</strong>：执行完成任务后，激活其他任务（其他任务可以拿到之前任务的返回值）</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">CompletableFuture<span style="color:#f92672">&lt;</span>Void<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">thenAcceptAsync</span><span style="color:#f92672">(</span>Consumer<span style="color:#f92672">&lt;?</span> <span style="color:#66d9ef">super</span> T<span style="color:#f92672">&gt;</span> action<span style="color:#f92672">,</span>Executor executor<span style="color:#f92672">)</span>
<span style="color:#f92672">&lt;</span>U<span style="color:#f92672">&gt;</span> CompletableFuture<span style="color:#f92672">&lt;</span>U<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">thenApplyAsync</span><span style="color:#f92672">(</span>Function<span style="color:#f92672">&lt;?</span> <span style="color:#66d9ef">super</span> T<span style="color:#f92672">,?</span> <span style="color:#66d9ef">extends</span> U<span style="color:#f92672">&gt;</span> fn<span style="color:#f92672">,</span> Executor executor<span style="color:#f92672">)</span>
 <span style="color:#75715e">//example
</span><span style="color:#75715e"></span>        CompletableFuture<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> future <span style="color:#f92672">=</span> CompletableFuture<span style="color:#f92672">.</span><span style="color:#a6e22e">supplyAsync</span><span style="color:#f92672">(()</span> <span style="color:#f92672">-&gt;</span> doSomeThing<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;task from thenRun1&#34;</span><span style="color:#f92672">),</span>POOL_EXECUTOR<span style="color:#f92672">);</span>
        CompletableFuture<span style="color:#f92672">&lt;</span>Void<span style="color:#f92672">&gt;</span> thenRunFuture <span style="color:#f92672">=</span> future<span style="color:#f92672">.</span><span style="color:#a6e22e">thenRunAsync</span><span style="color:#f92672">(()</span> <span style="color:#f92672">-&gt;</span> doSomeThing<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;task from thenRun2&#34;</span><span style="color:#f92672">),</span>POOL_EXECUTOR<span style="color:#f92672">);</span>

</code></pre></div><p><strong>whenCompleteAsync</strong>：设置回调函数，通过回调的方式，不会阻塞调用线程</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">CompletableFuture<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> future <span style="color:#f92672">=</span> CompletableFuture<span style="color:#f92672">.</span><span style="color:#a6e22e">supplyAsync</span><span style="color:#f92672">(()</span> <span style="color:#f92672">-&gt;</span> doSomeThing<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;task from supplyAsync&#34;</span><span style="color:#f92672">),</span> POOL_EXECUTOR<span style="color:#f92672">);</span>
       future<span style="color:#f92672">.</span><span style="color:#a6e22e">whenCompleteAsync</span><span style="color:#f92672">((</span>s<span style="color:#f92672">,</span> throwable<span style="color:#f92672">)</span> <span style="color:#f92672">-&gt;</span> <span style="color:#f92672">{</span>
           <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>Objects<span style="color:#f92672">.</span><span style="color:#a6e22e">nonNull</span><span style="color:#f92672">(</span>s<span style="color:#f92672">)){</span>
               log<span style="color:#f92672">.</span><span style="color:#a6e22e">info</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;result:{}&#34;</span><span style="color:#f92672">,</span>s<span style="color:#f92672">);</span>
           <span style="color:#f92672">}</span>
       <span style="color:#f92672">},</span>POOL_EXECUTOR<span style="color:#f92672">);</span>
</code></pre></div><h4 id="多completablefuture组合运算">多CompletableFuture组合运算</h4>
<p><strong>thenCompose</strong>：当一个CompletableFuture执行完毕后，执行另外一个CompletableFuture</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#f92672">&lt;</span>U<span style="color:#f92672">&gt;</span> CompletableFuture<span style="color:#f92672">&lt;</span>U<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">thenComposeAsync</span><span style="color:#f92672">(</span>
        Function<span style="color:#f92672">&lt;?</span> <span style="color:#66d9ef">super</span> T<span style="color:#f92672">,</span> <span style="color:#f92672">?</span> <span style="color:#66d9ef">extends</span> CompletionStage<span style="color:#f92672">&lt;</span>U<span style="color:#f92672">&gt;&gt;</span> fn<span style="color:#f92672">)</span>
</code></pre></div><p><strong>thenCombine</strong>：当两个并发运行的CompletableFuture任务都完成后，使用两者的结果作为参数再执行一个异步任务</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#f92672">&lt;</span>U<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> CompletableFuture<span style="color:#f92672">&lt;</span>V<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">thenCombineAsync</span><span style="color:#f92672">(</span>
        CompletionStage<span style="color:#f92672">&lt;?</span> <span style="color:#66d9ef">extends</span> U<span style="color:#f92672">&gt;</span> other<span style="color:#f92672">,</span>
        BiFunction<span style="color:#f92672">&lt;?</span> <span style="color:#66d9ef">super</span> T<span style="color:#f92672">,?</span> <span style="color:#66d9ef">super</span> U<span style="color:#f92672">,?</span> <span style="color:#66d9ef">extends</span> V<span style="color:#f92672">&gt;</span> fn<span style="color:#f92672">)</span> 
<span style="color:#75715e">//example
</span><span style="color:#75715e"></span> CompletableFuture<span style="color:#f92672">.</span><span style="color:#a6e22e">supplyAsync</span><span style="color:#f92672">(()</span> <span style="color:#f92672">-&gt;</span> doSomeThing<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;task from supplyAsync1&#34;</span><span style="color:#f92672">),</span> POOL_EXECUTOR<span style="color:#f92672">)</span>
                <span style="color:#f92672">.</span><span style="color:#a6e22e">thenCombineAsync</span><span style="color:#f92672">(</span>CompletableFuture
                                <span style="color:#f92672">.</span><span style="color:#a6e22e">supplyAsync</span><span style="color:#f92672">(()</span> <span style="color:#f92672">-&gt;</span> doSomeThing<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;task from supplyAsync2&#34;</span><span style="color:#f92672">),</span> POOL_EXECUTOR<span style="color:#f92672">)</span>
                        <span style="color:#f92672">,</span> <span style="color:#f92672">(</span>result1<span style="color:#f92672">,</span> result2<span style="color:#f92672">)</span> <span style="color:#f92672">-&gt;</span> result1 <span style="color:#f92672">+</span> result2<span style="color:#f92672">)</span>
                <span style="color:#f92672">.</span><span style="color:#a6e22e">whenCompleteAsync</span><span style="color:#f92672">((</span>s<span style="color:#f92672">,</span> throwable<span style="color:#f92672">)</span> <span style="color:#f92672">-&gt;</span> <span style="color:#f92672">{</span>
                    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>Objects<span style="color:#f92672">.</span><span style="color:#a6e22e">nonNull</span><span style="color:#f92672">(</span>s<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
                        log<span style="color:#f92672">.</span><span style="color:#a6e22e">info</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;result:{}&#34;</span><span style="color:#f92672">,</span> s<span style="color:#f92672">);</span>
                    <span style="color:#f92672">}</span>
                <span style="color:#f92672">},</span> POOL_EXECUTOR<span style="color:#f92672">);</span>

</code></pre></div><p><strong>allOf</strong>：等待多个并发运行的CompletableFuture任务执行完毕</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"> <span style="color:#66d9ef">static</span> CompletableFuture<span style="color:#f92672">&lt;</span>Void<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">allOf</span><span style="color:#f92672">(</span>CompletableFuture<span style="color:#f92672">&lt;?&gt;...</span> cfs<span style="color:#f92672">)</span> 
 <span style="color:#75715e">//example
</span><span style="color:#75715e"></span>ArrayList<span style="color:#f92672">&lt;</span>CompletableFuture<span style="color:#f92672">&gt;</span> futures <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ArrayList<span style="color:#f92672">&lt;&gt;();</span>
        futures<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>CompletableFuture<span style="color:#f92672">.</span><span style="color:#a6e22e">supplyAsync</span><span style="color:#f92672">(()</span> <span style="color:#f92672">-&gt;</span> doSomeThing<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;task from supplyAsync1&#34;</span><span style="color:#f92672">),</span> POOL_EXECUTOR<span style="color:#f92672">));</span>
        futures<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>CompletableFuture<span style="color:#f92672">.</span><span style="color:#a6e22e">supplyAsync</span><span style="color:#f92672">(()</span> <span style="color:#f92672">-&gt;</span> doSomeThing<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;task from supplyAsync2&#34;</span><span style="color:#f92672">),</span> POOL_EXECUTOR<span style="color:#f92672">));</span>
        futures<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>CompletableFuture<span style="color:#f92672">.</span><span style="color:#a6e22e">supplyAsync</span><span style="color:#f92672">(()</span> <span style="color:#f92672">-&gt;</span> doSomeThing<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;task from supplyAsync3&#34;</span><span style="color:#f92672">),</span> POOL_EXECUTOR<span style="color:#f92672">));</span>

        CompletableFuture<span style="color:#f92672">.</span><span style="color:#a6e22e">allOf</span><span style="color:#f92672">(</span>futures<span style="color:#f92672">.</span><span style="color:#a6e22e">toArray</span><span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> CompletableFuture<span style="color:#f92672">[</span>futures<span style="color:#f92672">.</span><span style="color:#a6e22e">size</span><span style="color:#f92672">()])).</span><span style="color:#a6e22e">get</span><span style="color:#f92672">();</span>
</code></pre></div><p><strong>anyOf</strong>：等多个并发运行的CompletableFuture任务任意一个执行完毕</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"> <span style="color:#66d9ef">static</span> CompletableFuture<span style="color:#f92672">&lt;</span>Object<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">anyOf</span><span style="color:#f92672">(</span>CompletableFuture<span style="color:#f92672">&lt;?&gt;...</span> cfs<span style="color:#f92672">)</span>
</code></pre></div><h4 id="异常处理">异常处理</h4>
<p>当出现异常时，可以调用future.completeExceptionally(e) 把异常信息设置到future内部，get获取时会把异常带出来，或者future.exceptionally设置出现异常时返回的默认值。</p>
<h4 id="stream与completablefuture">Stream与CompletableFuture</h4>
<p>可以使用map将一些数据传进CompletableFuture进行异步调用，并转换成CompletableFuture。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">List<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> requests <span style="color:#f92672">=</span> Arrays<span style="color:#f92672">.</span><span style="color:#a6e22e">asList</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;request1&#34;</span><span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;request2&#34;</span><span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;request3&#34;</span><span style="color:#f92672">);</span>

        <span style="color:#75715e">//转换成CompletableFuture，异步调用
</span><span style="color:#75715e"></span>        List<span style="color:#f92672">&lt;</span>CompletableFuture<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;&gt;</span> futures <span style="color:#f92672">=</span> requests<span style="color:#f92672">.</span><span style="color:#a6e22e">stream</span><span style="color:#f92672">()</span>
                <span style="color:#f92672">.</span><span style="color:#a6e22e">map</span><span style="color:#f92672">(</span>request <span style="color:#f92672">-&gt;</span> CompletableFuture<span style="color:#f92672">.</span><span style="color:#a6e22e">supplyAsync</span><span style="color:#f92672">(()</span> <span style="color:#f92672">-&gt;</span> getRpcResult<span style="color:#f92672">(</span>request<span style="color:#f92672">),</span> POOL_EXECUTOR<span style="color:#f92672">))</span>
                <span style="color:#f92672">.</span><span style="color:#a6e22e">collect</span><span style="color:#f92672">(</span>Collectors<span style="color:#f92672">.</span><span style="color:#a6e22e">toList</span><span style="color:#f92672">());</span>

        <span style="color:#75715e">//同步阻塞等待调用完毕，收集结果
</span><span style="color:#75715e"></span>        List<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> rpcResponse <span style="color:#f92672">=</span> futures<span style="color:#f92672">.</span><span style="color:#a6e22e">stream</span><span style="color:#f92672">()</span>
                <span style="color:#f92672">.</span><span style="color:#a6e22e">map</span><span style="color:#f92672">(</span>CompletableFuture<span style="color:#f92672">::</span>join<span style="color:#f92672">)</span>
                <span style="color:#f92672">.</span><span style="color:#a6e22e">collect</span><span style="color:#f92672">(</span>Collectors<span style="color:#f92672">.</span><span style="color:#a6e22e">toList</span><span style="color:#f92672">());</span>

        log<span style="color:#f92672">.</span><span style="color:#a6e22e">info</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;rpcResponse:{}&#34;</span><span style="color:#f92672">,</span> rpcResponse<span style="color:#f92672">);</span>
</code></pre></div><h3 id="rxjava与reactor">RxJava与Reactor</h3>
<p>响应式编程（Reactive Programming）是一种涉及数据流和变化传播的异步编程范式，可以通过所采用的编程语言轻松地表达静态（例如阵列）或动态（例如事件发射器）数据流。RxJava与Reactor都是对响应式编程理念实现，基于Reactive Streams标准，遵循了同一个规范，可以很轻易地从一方切换到另一方 。</p>
<p><strong>对比Java的异步编程模型</strong></p>
<p>Java提供了两种异步编程模型</p>
<p>CallBacks：异步方法没有返回值，绑定回调函数在结果可用时调用。</p>
<p>Futures：异步方法立即返回Future，异步线程计算任务，并当结果计算出来后设置到Future。</p>
<p><strong>CallBacks与Futures局限性</strong>：</p>
<p>多个Callback组合在一起后，容易形成回调地狱（Callback Hell）；多个Future难以编排，尽管是改进后的CompletableFuture，也存在不支持延迟计算和高级错误处理的缺陷。</p>
<p>响应式编程库基于声明式编程，比较Callbacks更通俗易懂，同时自带很多操作符，提供高级特性，简化处理。</p>
<p>参考对比：<a href="https://htmlpreview.github.io/?https://github.com/get-set/reactor-core/blob/master-zh/src/docs/index.html#_%E5%BC%82%E6%AD%A5%E5%8F%AF%E4%BB%A5%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98%E5%90%97">Reactor 3 参考文档</a></p>
<p><strong>响应式编程库通过如下几点弥补Java异步编程模型的不足</strong></p>
<ul>
<li><strong>可编排性（Composability）</strong> 以及 <strong>可读性（Readability）</strong></li>
<li>使用丰富的 <strong>操作符</strong> 来处理形如 <strong>流</strong> 的数据</li>
<li>在 <strong>订阅（subscribe）</strong> 之前什么都不会发生</li>
<li><strong>背压（backpressure）</strong> 具体来说即消费者能够反向告知生产者生产内容的速度的能力</li>
<li><strong>高层次</strong> （同时也是有高价值的）的抽象，从而达到 并发无关 的效果</li>
</ul>
<h4 id="基于rxjava实现异步编程">基于RxJava实现异步编程</h4>
<ul>
<li>observeOn（切换调度线程执行订阅者函数）</li>
</ul>
<p>注意，observeOn切换到了其他线程异步执行，但是事件还是按发送顺序同步执行。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">   Flowable<span style="color:#f92672">.</span><span style="color:#a6e22e">fromArray</span><span style="color:#f92672">(</span>requests<span style="color:#f92672">.</span><span style="color:#a6e22e">toArray</span><span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> String<span style="color:#f92672">[</span>0<span style="color:#f92672">]))</span>
                <span style="color:#75715e">//切换到IO调度线程执行订阅者函数
</span><span style="color:#75715e"></span>                <span style="color:#f92672">.</span><span style="color:#a6e22e">observeOn</span><span style="color:#f92672">(</span>Schedulers<span style="color:#f92672">.</span><span style="color:#a6e22e">io</span><span style="color:#f92672">())</span>
                <span style="color:#75715e">//异步调用，按发布顺序顺序执行
</span><span style="color:#75715e"></span>                <span style="color:#f92672">.</span><span style="color:#a6e22e">map</span><span style="color:#f92672">(</span><span style="color:#66d9ef">this</span><span style="color:#f92672">::</span>getRpcResponse<span style="color:#f92672">)</span>
                <span style="color:#f92672">.</span><span style="color:#a6e22e">subscribe</span><span style="color:#f92672">(</span>response<span style="color:#f92672">-&gt;</span>log<span style="color:#f92672">.</span><span style="color:#a6e22e">info</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;get Rpc Response:{}&#34;</span><span style="color:#f92672">,</span>response<span style="color:#f92672">));</span>
</code></pre></div><ul>
<li>subscribeOn（切换到调度线程执行发布者函数）</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">Flowable<span style="color:#f92672">.</span><span style="color:#a6e22e">fromCallable</span><span style="color:#f92672">(</span><span style="color:#66d9ef">this</span><span style="color:#f92672">::</span>generateRequests<span style="color:#f92672">)</span>
            <span style="color:#75715e">//切换到IO调度线程执行发布者函数
</span><span style="color:#75715e"></span>                <span style="color:#f92672">.</span><span style="color:#a6e22e">subscribeOn</span><span style="color:#f92672">(</span>Schedulers<span style="color:#f92672">.</span><span style="color:#a6e22e">io</span><span style="color:#f92672">())</span>
            <span style="color:#75715e">//切换到Signle调度线程执行订阅者函数
</span><span style="color:#75715e"></span>                <span style="color:#f92672">.</span><span style="color:#a6e22e">observeOn</span><span style="color:#f92672">(</span>Schedulers<span style="color:#f92672">.</span><span style="color:#a6e22e">single</span><span style="color:#f92672">())</span>
                <span style="color:#f92672">.</span><span style="color:#a6e22e">subscribe</span><span style="color:#f92672">(</span>System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">::</span>print<span style="color:#f92672">);</span>
</code></pre></div><ul>
<li>flatMap与subscribeOn进行并发调用</li>
</ul>
<p>针对上述observeOn例子顺序执行的情况，要做到并发执行，我们可以通过flatMap操作符配合subscribeOn进行操作。如下所示，使用flatMap将Request参数转换为Flowable，利用subscribeOn切换到调度线程执行，做到了并发调用。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">  Flowable<span style="color:#f92672">.</span><span style="color:#a6e22e">fromArray</span><span style="color:#f92672">(</span>generateRequests<span style="color:#f92672">())</span>
                <span style="color:#f92672">.</span><span style="color:#a6e22e">flatMap</span><span style="color:#f92672">(</span>requests <span style="color:#f92672">-&gt;</span>
                        <span style="color:#75715e">//flatMap将Request转换为Flowable对象
</span><span style="color:#75715e"></span>                        Flowable<span style="color:#f92672">.</span><span style="color:#a6e22e">just</span><span style="color:#f92672">(</span>requests<span style="color:#f92672">)</span>
                                <span style="color:#75715e">//切换到调度线程执行发布者函数
</span><span style="color:#75715e"></span>                                <span style="color:#f92672">.</span><span style="color:#a6e22e">subscribeOn</span><span style="color:#f92672">(</span>Schedulers<span style="color:#f92672">.</span><span style="color:#a6e22e">io</span><span style="color:#f92672">())</span>
                                <span style="color:#75715e">//执行rpc调用转换成Response
</span><span style="color:#75715e"></span>                                <span style="color:#f92672">.</span><span style="color:#a6e22e">map</span><span style="color:#f92672">(</span><span style="color:#66d9ef">this</span><span style="color:#f92672">::</span>getRpcResponse<span style="color:#f92672">))</span>
                <span style="color:#75715e">//阻塞等待所有的rpc调用并发执行完毕
</span><span style="color:#75715e"></span>                <span style="color:#f92672">.</span><span style="color:#a6e22e">blockingSubscribe</span><span style="color:#f92672">(</span>System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">::</span>print<span style="color:#f92672">);</span>
</code></pre></div><h4 id="基于reactor实现异步编程">基于Reactor实现异步编程</h4>
<p>Reactor中的流操作符与RxJava基本相同，下面简单重写了上述RxJava的例子</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">  
  Flux<span style="color:#f92672">.</span><span style="color:#a6e22e">fromArray</span><span style="color:#f92672">(</span>generateRequests<span style="color:#f92672">())</span>
                <span style="color:#f92672">.</span><span style="color:#a6e22e">flatMap</span><span style="color:#f92672">(</span>requests <span style="color:#f92672">-&gt;</span>
                        <span style="color:#75715e">//flatMap将Request转换为Flowable对象
</span><span style="color:#75715e"></span>                        Flux<span style="color:#f92672">.</span><span style="color:#a6e22e">just</span><span style="color:#f92672">(</span>requests<span style="color:#f92672">)</span>
                                <span style="color:#75715e">//切换到调度线程执行发布者函数
</span><span style="color:#75715e"></span>                                <span style="color:#f92672">.</span><span style="color:#a6e22e">subscribeOn</span><span style="color:#f92672">(</span>Schedulers<span style="color:#f92672">.</span><span style="color:#a6e22e">elastic</span><span style="color:#f92672">())</span>
                                <span style="color:#75715e">//执行rpc调用转换成Response
</span><span style="color:#75715e"></span>                                <span style="color:#f92672">.</span><span style="color:#a6e22e">map</span><span style="color:#f92672">(</span><span style="color:#66d9ef">this</span><span style="color:#f92672">::</span>getRpcResponse<span style="color:#f92672">))</span>
                <span style="color:#f92672">.</span><span style="color:#a6e22e">subscribe</span><span style="color:#f92672">(</span>response <span style="color:#f92672">-&gt;</span> <span style="color:#f92672">{</span>
                    log<span style="color:#f92672">.</span><span style="color:#a6e22e">info</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;get rpc response :{}&#34;</span><span style="color:#f92672">,</span> response<span style="color:#f92672">);</span>
                <span style="color:#f92672">});</span>
                
Flux<span style="color:#f92672">.</span><span style="color:#a6e22e">fromArray</span><span style="color:#f92672">(</span>generateRequests<span style="color:#f92672">())</span>
                <span style="color:#75715e">//切换到IO调度线程执行订阅者函数
</span><span style="color:#75715e"></span>                <span style="color:#f92672">.</span><span style="color:#a6e22e">publishOn</span><span style="color:#f92672">(</span>Schedulers<span style="color:#f92672">.</span><span style="color:#a6e22e">elastic</span><span style="color:#f92672">())</span>
                <span style="color:#f92672">.</span><span style="color:#a6e22e">map</span><span style="color:#f92672">(</span><span style="color:#66d9ef">this</span><span style="color:#f92672">::</span>getRpcResponse<span style="color:#f92672">)</span>
                <span style="color:#f92672">.</span><span style="color:#a6e22e">subscribe</span><span style="color:#f92672">(</span>response <span style="color:#f92672">-&gt;</span> log<span style="color:#f92672">.</span><span style="color:#a6e22e">info</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;get Rpc Response:{}&#34;</span><span style="color:#f92672">,</span> response<span style="color:#f92672">));</span>
</code></pre></div><h3 id="spring的taskexecutor">Spring的TaskExecutor</h3>
<p>Spring 2.0版本开始提供了一种新的处理执行器（executors）的抽象，TaskExecutor。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">TaskExecutor</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">execute</span><span style="color:#f92672">(</span>Runnable task<span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
</code></pre></div><p><strong>Spring内置TaskExecutor实现</strong></p>
<ul>
<li>SimpleAsyncTaskExecutor（每个请求会新创建一个对应的线程来执行）</li>
<li>SyncTaskExecutor（同步使用调用线程来执行任务）</li>
<li>ConcurrentTaskExecutor（对JDK5中的java.util.concurrent.Executor的一个包装，通过setConcurrentExecutor设置一个JUC中的线程池到其内部来做适配）</li>
<li>SimpleThreadPoolTaskExecutor（Quartz的SimpleThreadPool的子类，会监听Spring的生命周期回调）</li>
<li>ThreadPoolTaskExecutor（比较常用，用于配置java.util.concurrent.ThreadPoolExecutor并将其包装在TaskExecutor中。如果需要一些高级的接口，例如ScheduledThreadPoolExecutor，可以使用Concurrent TaskExecutor）</li>
<li>TimerTaskExecutor（对所有提交的任务都在Timer内的单独线程中执行）</li>
</ul>
<h4 id="在springboot中使用taskexecutor进行异步处理">在SpringBoot中使用TaskExecutor进行异步处理</h4>
<ol>
<li>配置Executor参数</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#a6e22e">@Slf4j</span>
<span style="color:#a6e22e">@Configuration</span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">AsyncTaskConfig</span> <span style="color:#66d9ef">implements</span> AsyncConfigurer <span style="color:#f92672">{</span>

    <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">public</span> Executor <span style="color:#a6e22e">getAsyncExecutor</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        ThreadPoolTaskExecutor threadPoolTaskExecutor <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ThreadPoolTaskExecutor<span style="color:#f92672">();</span>
        threadPoolTaskExecutor<span style="color:#f92672">.</span><span style="color:#a6e22e">setThreadNamePrefix</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;AsyncThread-&#34;</span><span style="color:#f92672">);</span>
        threadPoolTaskExecutor<span style="color:#f92672">.</span><span style="color:#a6e22e">setCorePoolSize</span><span style="color:#f92672">(</span>100<span style="color:#f92672">);</span>
        threadPoolTaskExecutor<span style="color:#f92672">.</span><span style="color:#a6e22e">setMaxPoolSize</span><span style="color:#f92672">(</span>100<span style="color:#f92672">);</span>
        threadPoolTaskExecutor<span style="color:#f92672">.</span><span style="color:#a6e22e">setRejectedExecutionHandler</span><span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> ThreadPoolExecutor<span style="color:#f92672">.</span><span style="color:#a6e22e">CallerRunsPolicy</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
            <span style="color:#a6e22e">@Override</span>
            <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">rejectedExecution</span><span style="color:#f92672">(</span>Runnable r<span style="color:#f92672">,</span> ThreadPoolExecutor e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                <span style="color:#75715e">// 打印线程池异常信息...
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">super</span><span style="color:#f92672">.</span><span style="color:#a6e22e">rejectedExecution</span><span style="color:#f92672">(</span>r<span style="color:#f92672">,</span> e<span style="color:#f92672">);</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">});</span>
        <span style="color:#75715e">//关闭执行器时不等待正在执行的任务执行完毕就中断执行任务的线程
</span><span style="color:#75715e"></span>        threadPoolTaskExecutor<span style="color:#f92672">.</span><span style="color:#a6e22e">setWaitForTasksToCompleteOnShutdown</span><span style="color:#f92672">(</span><span style="color:#66d9ef">true</span><span style="color:#f92672">);</span>
        threadPoolTaskExecutor<span style="color:#f92672">.</span><span style="color:#a6e22e">afterPropertiesSet</span><span style="color:#f92672">();</span>
        <span style="color:#66d9ef">return</span> threadPoolTaskExecutor<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
	
	<span style="color:#75715e">//拒绝策略
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">public</span> AsyncUncaughtExceptionHandler <span style="color:#a6e22e">getAsyncUncaughtExceptionHandler</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> SimpleAsyncUncaughtExceptionHandler<span style="color:#f92672">();</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>

</code></pre></div><ol start="2">
<li>在SpringBootApplication类上添加@EnableAsync注解。</li>
<li>在方法上添加@Async，异步执行该方法，该方法的实际执行将发生在Spring的TaskExecutor异步处理器线程中。基于@Async注解的异步处理是支持返回值的，但是返回值类型必须是Future或者其子类类型的，如JDK的Future类型，Spring框架的ListenableFuture类型，或者JDK8中的 CompletableFuture类型，又或者Spring中的AsyncResult类型等。</li>
</ol>
<h4 id="async注解执行原理">@Async注解执行原理</h4>
<p>@EnableAsync开启后会把ProxyAsyncConfiguration的实例注入Spring容器。默认情况下，Spring框架是使用Cglib对标注@Async注解的方法进行代理的，具体拦截器是AnnotationAsyncExecutionInterceptor作为切面逻辑，当我们调用含有@Async注解的Bean的方法时候，实际调用的是被代理后的Bean，AnnotationAsyncExecutionInterceptor的invoke方法如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">        <span style="color:#66d9ef">public</span> Object <span style="color:#a6e22e">invoke</span><span style="color:#f92672">(</span><span style="color:#66d9ef">final</span> MethodInvocation invocation<span style="color:#f92672">)</span> <span style="color:#66d9ef">throws</span> Throwable <span style="color:#f92672">{</span>
            <span style="color:#75715e">//1．被代理的目标对象
</span><span style="color:#75715e"></span>            Class<span style="color:#f92672">&lt;?</span> <span style="color:#f92672">&gt;</span> targetClass <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>invocation<span style="color:#f92672">.</span><span style="color:#a6e22e">getThis</span><span style="color:#f92672">()</span> <span style="color:#f92672">!</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">?</span> AopUtils<span style="color:#f92672">.</span>
        <span style="color:#a6e22e">getTargetClass</span><span style="color:#f92672">(</span>invocation<span style="color:#f92672">.</span><span style="color:#a6e22e">getThis</span><span style="color:#f92672">())</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">);</span>
        <span style="color:#75715e">//2. 获取被代理的方法
</span><span style="color:#75715e"></span>        Method specificMethod <span style="color:#f92672">=</span> ClassUtils<span style="color:#f92672">.</span><span style="color:#a6e22e">getMostSpecificMethod</span><span style="color:#f92672">(</span>invocation<span style="color:#f92672">.</span>
    <span style="color:#a6e22e">getMethod</span><span style="color:#f92672">(),</span> targetClass<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">final</span> Method userDeclaredMethod <span style="color:#f92672">=</span> BridgeMethodResolver<span style="color:#f92672">.</span><span style="color:#a6e22e">findBridgedMethod</span><span style="color:#f92672">(</span>
    specificMethod<span style="color:#f92672">);</span>
        <span style="color:#75715e">//3. 判断使用哪个执行器执行被代理的方法
</span><span style="color:#75715e"></span>        AsyncTaskExecutor executor <span style="color:#f92672">=</span> determineAsyncExecutor<span style="color:#f92672">(</span>userDeclaredMethod<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>executor <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> IllegalStateException<span style="color:#f92672">(</span>
                    <span style="color:#e6db74">&#34;No executor specified and no default executor set on
</span><span style="color:#e6db74">    AsyncExecutionInterceptor either&#34;</span><span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
        <span style="color:#75715e">//4. 使用Callable包装要执行的方法
</span><span style="color:#75715e"></span>        Callable<span style="color:#f92672">&lt;</span>Object<span style="color:#f92672">&gt;</span> task <span style="color:#f92672">=</span> <span style="color:#f92672">()</span> <span style="color:#f92672">-&gt;</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
                Object result <span style="color:#f92672">=</span> invocation<span style="color:#f92672">.</span><span style="color:#a6e22e">proceed</span><span style="color:#f92672">();</span>
                <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>result <span style="color:#66d9ef">instanceof</span> Future<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                    <span style="color:#66d9ef">return</span> <span style="color:#f92672">((</span>Future<span style="color:#f92672">&lt;?</span> <span style="color:#f92672">&gt;)</span> result<span style="color:#f92672">).</span><span style="color:#a6e22e">get</span><span style="color:#f92672">();</span>
                <span style="color:#f92672">}</span>
            <span style="color:#f92672">}</span>
            <span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>ExecutionException ex<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                      handleError<span style="color:#f92672">(</span>ex<span style="color:#f92672">.</span><span style="color:#a6e22e">getCause</span><span style="color:#f92672">(),</span>  userDeclaredMethod<span style="color:#f92672">,</span>  invocation<span style="color:#f92672">.</span>
    <span style="color:#a6e22e">getArguments</span><span style="color:#f92672">());</span>
            <span style="color:#f92672">}</span>
            <span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>Throwable ex<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                handleError<span style="color:#f92672">(</span>ex<span style="color:#f92672">,</span> userDeclaredMethod<span style="color:#f92672">,</span> invocation<span style="color:#f92672">.</span><span style="color:#a6e22e">getArguments</span><span style="color:#f92672">());</span>
            <span style="color:#f92672">}</span>
            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">};</span>
        <span style="color:#75715e">//5. 提交包装的Callable任务到指定执行器执行
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> doSubmit<span style="color:#f92672">(</span>task<span style="color:#f92672">,</span> executor<span style="color:#f92672">,</span> invocation<span style="color:#f92672">.</span><span style="color:#a6e22e">getMethod</span><span style="color:#f92672">().</span><span style="color:#a6e22e">getReturnType</span><span style="color:#f92672">());</span>
    <span style="color:#f92672">}</span>

</code></pre></div><p>doSubmit会判断方法的返回值类型进行包装，然后提交到线程池中运行。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">        <span style="color:#66d9ef">protected</span>  Object  <span style="color:#a6e22e">doSubmit</span><span style="color:#f92672">(</span>Callable<span style="color:#f92672">&lt;</span>Object<span style="color:#f92672">&gt;</span>  task<span style="color:#f92672">,</span>  AsyncTaskExecutor  executor<span style="color:#f92672">,</span>
        Class<span style="color:#f92672">&lt;?</span> <span style="color:#f92672">&gt;</span> returnType<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#75715e">//5.1判断方法返回值是否为CompletableFuture类型或者是其子类
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>CompletableFuture<span style="color:#f92672">.</span><span style="color:#a6e22e">class</span><span style="color:#f92672">.</span><span style="color:#a6e22e">isAssignableFrom</span><span style="color:#f92672">(</span>returnType<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
                <span style="color:#66d9ef">return</span> CompletableFuture<span style="color:#f92672">.</span><span style="color:#a6e22e">supplyAsync</span><span style="color:#f92672">(()</span> <span style="color:#f92672">-&gt;</span> <span style="color:#f92672">{</span>
                    <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
                        <span style="color:#66d9ef">return</span> task<span style="color:#f92672">.</span><span style="color:#a6e22e">call</span><span style="color:#f92672">();</span>
                    <span style="color:#f92672">}</span>
                    <span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>Throwable ex<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                        <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> CompletionException<span style="color:#f92672">(</span>ex<span style="color:#f92672">);</span>
                    <span style="color:#f92672">}</span>
                <span style="color:#f92672">},</span> executor<span style="color:#f92672">);</span>
            <span style="color:#f92672">}</span>
            <span style="color:#75715e">//5.2判断返回值类型是否为ListenableFuture类型或者是其子类
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>ListenableFuture<span style="color:#f92672">.</span><span style="color:#a6e22e">class</span><span style="color:#f92672">.</span><span style="color:#a6e22e">isAssignableFrom</span><span style="color:#f92672">(</span>returnType<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
                <span style="color:#66d9ef">return</span> <span style="color:#f92672">((</span>AsyncListenableTaskExecutor<span style="color:#f92672">)</span> executor<span style="color:#f92672">).</span>
        submitListenable<span style="color:#f92672">(</span>task<span style="color:#f92672">);</span>
            <span style="color:#f92672">}</span>
            <span style="color:#75715e">//5.3判断返回值类型是否为ListenableFuture类型或者是其子类
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>Future<span style="color:#f92672">.</span><span style="color:#a6e22e">class</span><span style="color:#f92672">.</span><span style="color:#a6e22e">isAssignableFrom</span><span style="color:#f92672">(</span>returnType<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
                <span style="color:#66d9ef">return</span> executor<span style="color:#f92672">.</span><span style="color:#a6e22e">submit</span><span style="color:#f92672">(</span>task<span style="color:#f92672">);</span>
            <span style="color:#f92672">}</span>
            <span style="color:#75715e">//5.4其他情况下没有返回值
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
                executor<span style="color:#f92672">.</span><span style="color:#a6e22e">submit</span><span style="color:#f92672">(</span>task<span style="color:#f92672">);</span>
                <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>

</code></pre></div><h3 id="servlet异步编程">Servlet异步编程</h3>
<p>Servlet3.0规范前，Servlet容器的线程模型如下：</p>
<p><img src="https://user-images.githubusercontent.com/19829495/78469509-7a3d0900-7754-11ea-9e39-92d28ccfa1f4.png" alt="图片"></p>
<p>每个请求对应一个线程这种1 : 1的模式进行处理的同步线程模型，线程数是有限的，当线程池资源耗尽后就不能接收处理新的请求了，限制了服务器的并发请求数。</p>
<h4 id="servlet30-提供的异步处理">Servlet3.0 提供的异步处理</h4>
<p>Servlet 3.0规范中引入了异步处理请求的能力，相对3.0之前的同步线程模型，Servlet内开启异步处理后会立刻释放Servlet容器线程，具体对请求进行处理与响应的是业务线程池中的线程。</p>
<p><img src="https://user-images.githubusercontent.com/19829495/78469647-d3596c80-7755-11ea-967e-f820e665c938.png" alt="图片"></p>
<p>官方例子：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#a6e22e">@WebServlet</span><span style="color:#f92672">(</span>urlPatterns<span style="color:#f92672">={</span><span style="color:#e6db74">&#34;/asyncservlet&#34;</span><span style="color:#f92672">},</span> asyncSupported<span style="color:#f92672">=</span><span style="color:#66d9ef">true</span><span style="color:#f92672">)</span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">AsyncServlet</span> <span style="color:#66d9ef">extends</span> HttpServlet <span style="color:#f92672">{</span>
   <span style="color:#75715e">/* ... Same variables and init method as in SyncServlet ... */</span>

   <span style="color:#a6e22e">@Override</span>
   <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">doGet</span><span style="color:#f92672">(</span>HttpServletRequest request<span style="color:#f92672">,</span> 
                     HttpServletResponse response<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
      response<span style="color:#f92672">.</span><span style="color:#a6e22e">setContentType</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;text/html;charset=UTF-8&#34;</span><span style="color:#f92672">);</span>
      <span style="color:#66d9ef">final</span> AsyncContext acontext <span style="color:#f92672">=</span> request<span style="color:#f92672">.</span><span style="color:#a6e22e">startAsync</span><span style="color:#f92672">();</span>
      acontext<span style="color:#f92672">.</span><span style="color:#a6e22e">start</span><span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> Runnable<span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
         <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
            String param <span style="color:#f92672">=</span> acontext<span style="color:#f92672">.</span><span style="color:#a6e22e">getRequest</span><span style="color:#f92672">().</span><span style="color:#a6e22e">getParameter</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;param&#34;</span><span style="color:#f92672">);</span>
            String result <span style="color:#f92672">=</span> resource<span style="color:#f92672">.</span><span style="color:#a6e22e">process</span><span style="color:#f92672">(</span>param<span style="color:#f92672">);</span>
            HttpServletResponse response <span style="color:#f92672">=</span> acontext<span style="color:#f92672">.</span><span style="color:#a6e22e">getResponse</span><span style="color:#f92672">();</span>
            <span style="color:#75715e">/* ... print to the response ... */</span>
            acontext<span style="color:#f92672">.</span><span style="color:#a6e22e">complete</span><span style="color:#f92672">();</span>
            <span style="color:#f92672">}</span>
      <span style="color:#f92672">});</span>
   <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><h4 id="servlet31-提供的非阻塞io处理">Servlet3.1 提供的非阻塞IO处理</h4>
<p>Servlet 3.0规范让Servlet的执行变为了异步，但是其IO还是阻塞式的（从ServletInputStream中读取请求体时是阻塞的）。</p>
<p>在Servlet3.1规范中提供了非阻塞IO处理方式，（当内核支持）Servlet3.1允许我们在ServletInputStream上通过函数setReadListener注册一个监听器，该监听器在发现内核有数据时才会进行回调处理函数。</p>
<p><img src="https://user-images.githubusercontent.com/19829495/78470533-e9b6f680-775c-11ea-90fb-237d03f65eda.png" alt="图片"></p>
<p>示例：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">				<span style="color:#66d9ef">final</span> AsyncContext asyncContext <span style="color:#f92672">=</span> req<span style="color:#f92672">.</span><span style="color:#a6e22e">startAsync</span><span style="color:#f92672">();</span>

                <span style="color:#75715e">//设置数据就绪监听器
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">final</span> ServletInputStream inputStream <span style="color:#f92672">=</span> req<span style="color:#f92672">.</span><span style="color:#a6e22e">getInputStream</span><span style="color:#f92672">();</span>
                inputStream<span style="color:#f92672">.</span><span style="color:#a6e22e">setReadListener</span><span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> ReadListener<span style="color:#f92672">()</span> <span style="color:#f92672">{</span>

                    <span style="color:#a6e22e">@Override</span>
                    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">onError</span><span style="color:#f92672">(</span>Throwable throwable<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                      <span style="color:#75715e">//异常处理
</span><span style="color:#75715e"></span>                    <span style="color:#f92672">}</span>

                    <span style="color:#a6e22e">@Override</span>
                    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">onDataAvailable</span><span style="color:#f92672">()</span> <span style="color:#66d9ef">throws</span> IOException <span style="color:#f92672">{</span>
                      <span style="color:#75715e">//数据就绪时回调，获取数据流
</span><span style="color:#75715e"></span>                            <span style="color:#66d9ef">final</span> ServletInputStream inputStream <span style="color:#f92672">=</span> asyncContext<span style="color:#f92672">.</span>
    <span style="color:#a6e22e">getRequest</span><span style="color:#f92672">().</span><span style="color:#a6e22e">getInputStream</span><span style="color:#f92672">();</span>
                <span style="color:#f92672">}</span>

                <span style="color:#a6e22e">@Override</span>
                <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">onAllDataRead</span><span style="color:#f92672">()</span> <span style="color:#66d9ef">throws</span> IOException <span style="color:#f92672">{</span>
                <span style="color:#75715e">//请求体的数据全部被读取完毕后，进行业务处理
</span><span style="color:#75715e"></span>                  <span style="color:#f92672">}</span>
              <span style="color:#f92672">}</span>

</code></pre></div><h3 id="netty">Netty</h3>
<p>Netty是一个异步、基于事件驱动的网络应用程序框架，其对Java NIO进行了封装，简化了TCP或者UDP服务器的网络编程开发。</p>
<p>Netty框架将网络编程逻辑与业务逻辑处理分离开来，其内部会自动处理好网络与异步处理逻辑，使用者只需要关注逻辑处理。Netty的异步非阻塞能力与CompletableFuture结合可以让我们轻松实现网络请求的异步调用。</p>
<p>很多现代化，高性能的Web框架，RPC框架底层都是用来Netty来实现，例如WebFlux，Vert.x，Dubbo，RocketMq&hellip;。</p>
<h4 id="线程模型">线程模型</h4>
<p><img src="https://user-images.githubusercontent.com/19829495/78472669-589c4b80-776d-11ea-8e26-d2fcadc94b57.png" alt="图片"></p>
<p>以Netty Server端为例子，NettyServer启动时会创建两个NioEventLoop Group线程池组，其中boss组用来接收客户端发来的连接，worker组则负责对完成TCP三次握手的连接进行处理；图中每个NioEventLoopGroup里面包含了多个Nio EventLoop，每个NioEventLoop中包含了一个NIO Selector、一个队列、一个线程；其中线程用来做轮询注册到Selector上的Channel的读写事件和对投递到队列里面的事件进行处理。</p>
<p>当客户端发来一个连接请求时，boss线程池组中注册了监听套接字的NioEventLoop中的Selector会读取TCP三次握手的请求，然后创建对应的连接套接字通道NioSocketChannel，接着把其注册到worker线程池组的某一个NioEventLoop中管理的一个NIO Selector上，该连接套接字通道NioSocketChannel上的所有读写事件都由该NioEventLoop管理。</p>
<ul>
<li>非阻塞write</li>
</ul>
<p>NioSocketChannel的write系列方法向连接里面写入数据时是非阻塞的，具体实现是执行write方法时判断是否是IO线程调用，不是则把写入请求封装为WriteTask并投递到与其对应的NioEventLoop中的队列里面。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">        <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">write</span><span style="color:#f92672">(</span>Object msg<span style="color:#f92672">,</span> <span style="color:#66d9ef">boolean</span> flush<span style="color:#f92672">,</span> ChannelPromise promise<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#f92672">...</span>
            <span style="color:#75715e">//1．如果调用线程是IO线程,直接执行
</span><span style="color:#75715e"></span>            EventExecutor executor <span style="color:#f92672">=</span> next<span style="color:#f92672">.</span><span style="color:#a6e22e">executor</span><span style="color:#f92672">();</span>
              <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>executor<span style="color:#f92672">.</span><span style="color:#a6e22e">inEventLoop</span><span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
                  <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>flush<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                      next<span style="color:#f92672">.</span><span style="color:#a6e22e">invokeWriteAndFlush</span><span style="color:#f92672">(</span>m<span style="color:#f92672">,</span> promise<span style="color:#f92672">);</span>
                  <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
                      next<span style="color:#f92672">.</span><span style="color:#a6e22e">invokeWrite</span><span style="color:#f92672">(</span>m<span style="color:#f92672">,</span> promise<span style="color:#f92672">);</span>
                  <span style="color:#f92672">}</span>
              <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span><span style="color:#75715e">//2．如果调用线程不是IO线程，封装为WriteTask投递到对应的NioEventLoop中的队列，NioEventLoop的线程轮询队列处理
</span><span style="color:#75715e"></span>                  AbstractWriteTask task<span style="color:#f92672">;</span>
                  <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>flush<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                      task <span style="color:#f92672">=</span> WriteAndFlushTask<span style="color:#f92672">.</span><span style="color:#a6e22e">newInstance</span><span style="color:#f92672">(</span>next<span style="color:#f92672">,</span> m<span style="color:#f92672">,</span> promise<span style="color:#f92672">);</span>
                  <span style="color:#f92672">}</span>   <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
                      task <span style="color:#f92672">=</span> WriteTask<span style="color:#f92672">.</span><span style="color:#a6e22e">newInstance</span><span style="color:#f92672">(</span>next<span style="color:#f92672">,</span> m<span style="color:#f92672">,</span> promise<span style="color:#f92672">);</span>
                  <span style="color:#f92672">}</span>
                  safeExecute<span style="color:#f92672">(</span>executor<span style="color:#f92672">,</span> task<span style="color:#f92672">,</span> promise<span style="color:#f92672">,</span> m<span style="color:#f92672">);</span>
              <span style="color:#f92672">}</span>
          <span style="color:#f92672">}</span>

</code></pre></div><ul>
<li>非阻塞read</li>
</ul>
<p>NioSocketChannel中读取数据时，等NioEventLoop中的IO轮询线程发现Selector上有数据就绪时，通过事件通知方式来通知我们业务数据已经就绪，是非阻塞的。</p>


      
        <div class="blog-tags">
          
            <a
              href="https://chinalhr.github.io/tags/java/"
              >Java</a
            >&nbsp;
          
            <a
              href="https://chinalhr.github.io/tags/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"
              >异步编程</a
            >&nbsp;
          
        </div>
      
    </article>
    
      <script>
  var backtotopButton = document.getElementById('backtotopButton')

  document.addEventListener('scroll', function () {
    if (
      document.body.scrollTop > 50 ||
      document.documentElement.scrollTop > 50
    ) {
      backtotopButton.style.opacity = '1'
    } else {
      backtotopButton.style.opacity = '0'
    }
  })

  function topFunction() {
    document.body.scrollTop = 0 
    document.documentElement.scrollTop = 0 
  }

  
  document.dispatchEvent(new CustomEvent('scroll'))
  backtotopButton.style.display = 'block'
</script>

      <button onclick="topFunction()" id="backtotopButton">
        <em class="fa fa-angle-up"></em>
      </button>
      <script>
  var backtotopButton = document.getElementById('backtotopButton')

  document.addEventListener('scroll', function () {
    if (
      document.body.scrollTop > 50 ||
      document.documentElement.scrollTop > 50
    ) {
      backtotopButton.style.opacity = '1'
    } else {
      backtotopButton.style.opacity = '0'
    }
  })

  function topFunction() {
    document.body.scrollTop = 0 
    document.documentElement.scrollTop = 0 
  }

  
  document.dispatchEvent(new CustomEvent('scroll'))
  backtotopButton.style.display = 'block'
</script>

    
    
      

    
  </div>

    <footer>
  

<div class="social-icons">
  
    
    
      
      <a href="https://github.com/chinalhr" name="GitHub">
        <em class="fab fa-github"></em>
      </a>
    
       &nbsp;&ndash;&nbsp;
      <a href="mailto:13435500980@163.com" name="Email">
        <em class="fas fa-envelope"></em>
      </a>
    
  

  
</div>


  
  <div class="container">
    <p class="credits copyright">
      <a href="https://chinalhr.github.io/about">hanrong.li</a>
      &nbsp;&copy;
      2022
      
        &nbsp;/&nbsp;
        <a href="https://chinalhr.github.io/">ChinaLHR Blog</a>
      
      &nbsp;&ndash;&nbsp;
      <em class="fas fa-moon" id="dark-mode-toggle"></em>
    </p>

    <p class="credits theme-by">
      Powered By <a href="https://gohugo.io">Hugo</a>&nbsp;
      Theme
      <a href="https://github.com/matsuyoshi30/harbor">Harbor</a>
    </p>
  </div>
</footer>

  </body>
</html>
