<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
<title>Linux命令记录</title>


  
    
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-JLJBQBW5WM"></script>
    <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-JLJBQBW5WM');
  </script>
  




<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<link
  rel="alternate"
  type="application/rss+xml"
  href="https://chinalhr.github.io/index.xml"
  title="ChinaLHR Blog"
/>
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Linux命令记录"/>
<meta name="twitter:description" content="
日常Linux命令记录
"/>



<link rel="stylesheet" href="https://chinalhr.github.io/fontawesome/css/all.min.css" />




<link
  crossorigin="anonymous"
  href="/css/styles.min.css"
  integrity=""
  rel="preload stylesheet"
  as="style"
/>




<link
  id="dark-mode-theme"
  crossorigin="anonymous"
  href="/css/dark.min.css"
  integrity=""
  rel="preload stylesheet"
  as="style"
/>


<script>
  var darkTheme = document.getElementById('dark-mode-theme')
  var storedTheme = localStorage.getItem('dark-mode-storage')

  if (storedTheme === 'dark') {
    darkTheme.disabled = false
  } else if (storedTheme === 'light') {
    darkTheme.disabled = true
  }
</script>


<script defer crossorigin="anonymous" src="/js/theme.js" integrity=""></script>


<script defer crossorigin="anonymous" src="/js/instantpage.min.js" integrity=""></script><meta name="generator" content="Hugo 0.68.3" />
  </head>
  <body>
    
  




  <header>
    <nav class="navbar">
  <div class="nav">
    
      <a href="https://chinalhr.github.io/" class="nav-logo">
        <img
          src="https://chinalhr.github.io/images/icon.png"
          width="50"
          height="50"
          alt="Logo"
        />
      </a>
    

    <ul class="nav-links">
      
        
          <li>
            <a href="/about/" id="About"
              ><em class="fas fa-user fa-lg"></em
            ></a>
          </li>
          
      
        
          <li>
            <a href="/categories/" id="Categories"
              ><em class="fas fa-filter fa-lg"></em
            ></a>
          </li>
          
      
        
          <li>
            <a href="/tags/" id="Tags"
              ><em class="fas fa-tags fa-lg"></em
            ></a>
          </li>
          
      
        
          <li>
            <a href="/archives/" id="Archives"
              ><em class="fas fa-archive fa-lg"></em
            ></a>
          </li>
          
      
        
          <li>
            <a href="/search/" id="Search"
              ><em class="fas fa-search fa-lg"></em
            ></a>
          </li>
          
      
    </ul>
  </div>
</nav>

    <div class="intro-header">
      <div class="container">
        <div class="post-heading">
          
            <h1>
              Linux命令记录
            </h1>
          
          
            <span class="meta-post">
  <em class="fa fa-calendar-alt"></em
  >&nbsp;Apr 19, 2019
  
    &nbsp;&nbsp;&nbsp;<em class="fa fa-folder-open"></em>&nbsp;
    
      <a
        href="https://chinalhr.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"
        >操作系统</a
      >&nbsp;
    
  
</span>

          
        </div>
      </div>
    </div>
  </header>
  

    
  <div class="container" role="main">
    <article class="article" class="blog-post">
      <blockquote>
<p>日常Linux命令记录</p>
</blockquote>
<h3 id="日常操作">日常操作</h3>
<h4 id="find">find</h4>
<ul>
<li>格式</li>
</ul>
<pre><code>find [path...] [expression]

path:find命令所查找的目录路径。例如用.来表示当前目录，用/来表示系统根目录
expression:expression可以分为——&quot;-options [-print -exec -ok ...]&quot;

options:指定find命令的常用选项，下节详细介绍
print:find命令将匹配的文件输出到标准输出
exec:find命令对匹配的文件执行该参数所给出的shell命令
-ok:和-exec的作用相同，只不过以一种更为安全的模式来执行该参数所给出的shell命令，在执行每一个命令之前，都会给出提示，让用户来确定是否执行。
</code></pre><ul>
<li>options</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">    -type <span style="color:#f92672">[</span>查找某一类型的文件<span style="color:#f92672">]</span> 
    b - 块设备文件。 
    d - 目录。 
    c - 字符设备文件。 
    p - 管道文件。 
    l - 符号链接文件。 
    f - 普通文件

    -name <span style="color:#f92672">[</span>按照文件名查找文件<span style="color:#f92672">]</span>
    find /dir -name filename  在/dir目录及其子目录下面查找名字为filename的文件 
    
    -perm <span style="color:#f92672">[</span>按照文件权限来查找文件<span style="color:#f92672">]</span>
    find . -perm <span style="color:#ae81ff">755</span> –print 在当前目录下查找文件权限位为755的文件
    
    -user<span style="color:#f92672">[</span>按照文件属主来查找文件<span style="color:#f92672">]</span>
    find ~ -user sam –print 在$HOME目录中查找文件属主为sam的文件
    
    -group<span style="color:#f92672">[</span>按照文件所属的组来查找文件<span style="color:#f92672">]</span>
    find /apps -group gem –print 在/apps目录下查找属于gem用户组的文件 
    
    -mtime -n +n <span style="color:#f92672">[</span>按照文件的更改时间来查找文件， - n表示文件更改时间距现在n天以内，+ n表示文件更改时间距现在n天以前<span style="color:#f92672">]</span>
    find /var/adm -mtime +3 –print 在/var/adm目录下查找更改时间在3日以前的文件
    
    -size n：<span style="color:#f92672">[</span>c<span style="color:#f92672">]</span> 查找文件长度为n块的文件，带有c时表示文件长度以字节计。

</code></pre></div><ul>
<li>常用操作记录</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#75715e">#清除/root/log 目录或者子目录下 大于1G的log文件</span>
find /root/logs/ -name <span style="color:#e6db74">&#34;*.log&#34;</span> -size +1024M -exec rm -rf <span style="color:#f92672">{}</span> <span style="color:#ae81ff">\;</span>

</code></pre></div><ul>
<li>参考链接</li>
</ul>
<p><a href="https://www.cnblogs.com/skynet/archive/2010/12/25/1916873.html">https://www.cnblogs.com/skynet/archive/2010/12/25/1916873.html</a></p>
<h4 id="which">which</h4>
<p>which命令的作用是在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。也就是说，使用which命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。</p>
<ul>
<li>格式</li>
</ul>
<pre><code>which 可执行文件名称 
</code></pre><ul>
<li>命令参数</li>
</ul>
<pre><code>-n 　指定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名。
-p 　与-n参数相同，但此处的包括了文件的路径。
-w 　指定输出时栏位的宽度。
-V 　显示版本信息
</code></pre><ul>
<li>例子</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">which docker
/usr/bin/docker
</code></pre></div><h4 id="whereis">whereis</h4>
<p>whereis命令只能用于程序名的搜索，而且只搜索二进制文件（参数-b）、man说明文件（参数-m）和源代码文件（参数-s）。 whereis查找的速度很快，因为会从数据库中查找数据，而不是像find命令那样，通 过遍历硬盘来查找（注意： 数据库文件并不是实时更新，默认情况下时一星期更新一次）</p>
<ul>
<li>命令格式</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">whereis <span style="color:#f92672">[</span>-bmsu<span style="color:#f92672">]</span> <span style="color:#f92672">[</span>BMS 目录名 -f <span style="color:#f92672">]</span> 文件名
</code></pre></div><ul>
<li>命令参数</li>
</ul>
<pre><code>-b   定位可执行文件。
-m   定位帮助文件。
-s   定位源代码文件。
-u   搜索默认路径下除可执行文件、源代码文件、帮助文件以外的其它文件。
-B   指定搜索可执行文件的路径。
-M   指定搜索帮助文件的路径。
-S   指定搜索源代码文件的路径。
</code></pre><ul>
<li>例子</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">whereis docker
docker: /usr/bin/docker /etc/docker /usr/libexec/docker /usr/share/man/man1/docker.1.gz
</code></pre></div><h4 id="ps">ps</h4>
<p>ps命令用来列出系统中当前运行的那些进程。</p>
<ul>
<li>格式</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">ps<span style="color:#f92672">[</span>参数<span style="color:#f92672">]</span>

a  显示所有进程

-a 显示同一终端下的所有程序

-A 显示所有进程

c  显示进程的真实名称

-N 反向选择

-e 等于“-A”

e  显示环境变量

f  显示程序间的关系

-H 显示树状结构

r  显示当前终端的进程

T  显示当前终端的所有程序

u  指定用户的所有进程

-au 显示较详细的资讯

-aux 显示所有包含其他使用者的进程 
</code></pre></div><ul>
<li>常用操作记录</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#75715e"># ps 与grep 常用组合用法，查找特定进程</span>
ps -ef|grep java

<span style="color:#75715e"># 显示进程的层级信息</span>
ps -ef --forest
</code></pre></div><h4 id="tail">tail</h4>
<p>tail 命令从指定点开始将文件写到标准输出.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#75715e"># 显示末尾的10行</span>
tail logfile.log
<span style="color:#75715e"># 循环读取</span>
tail -f logfile.log
<span style="color:#75715e"># 显示文件末尾内容(最后五行)</span>
tail -n <span style="color:#ae81ff">5</span> logfile.log
<span style="color:#75715e"># 从第5行开始显示文件</span>
tail -n +5 logfile.log
</code></pre></div><h4 id="head">head</h4>
<p>head 用来显示档案的开头至标准输出中</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">head <span style="color:#f92672">[</span>参数<span style="color:#f92672">]</span>... <span style="color:#f92672">[</span>文件<span style="color:#f92672">]</span>...  
-q 隐藏文件名
-v 显示文件名
-c&lt;字节&gt; 显示字节数
-n&lt;行数&gt; 显示的行数
</code></pre></div><pre><code># 显示前5行
head -n 5 log2014.log 
</code></pre><h4 id="moreless">more|less</h4>
<p>more命令从前向后读取文件（在启动时就加载整个文件）<!-- raw HTML omitted -->
空白键（space）就往下一页显示，按 b 键就会往回（back）一页显示。</p>
<p>less命令<!-- raw HTML omitted --></p>
<p>d  向后翻半页 u  向前滚动半页 空格键 滚动一页</p>
<p>查询:?关键字 n 上一位 N 下一位</p>
<h4 id="scp">scp</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#75715e"># 复制文件</span>
scp local_file remote_username@remote_ip:remote_folder

<span style="color:#75715e"># 复制目录</span>
scp -r local_folder remote_username@remote_ip:remote_folder
</code></pre></div><h4 id="crontab">crontab</h4>
<p>crond是linux下用来周期性的执行某种任务或等待处理某些事件的一个守护进程。在/etc目录下的crontab文件</p>
<ul>
<li>格式</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">minute   hour   day   month   week   command

其中：

minute： 表示分钟，可以是从0到59之间的任何整数。

hour：表示小时，可以是从0到23之间的任何整数。

day：表示日期，可以是从1到31之间的任何整数。

month：表示月份，可以是从1到12之间的任何整数。

week：表示星期几，可以是从0到7之间的任何整数，这里的0或7代表星期日。

command：要执行的命令，可以是系统命令，也可以是自己编写的脚本文件。

crontab <span style="color:#f92672">[</span>-u user<span style="color:#f92672">]</span> <span style="color:#f92672">[</span> -e | -l | -r <span style="color:#f92672">]</span>

-e：编辑某个用户的crontab文件内容。如果不指定用户，则表示编辑当前用户的crontab文件。

-l：显示某个用户的crontab文件内容，如果不指定用户，则表示显示当前用户的crontab文件内容。

-r：从/var/spool/cron目录中删除某个用户的crontab文件，如果不指定用户，则默认删除当前用户的crontab文件。
</code></pre></div><ul>
<li>常用操作记录</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">查看所有用户的crontab
cat /etc/passwd | cut -f <span style="color:#ae81ff">1</span> -d : |xargs -I <span style="color:#f92672">{}</span> crontab -l -u <span style="color:#f92672">{}</span>
</code></pre></div><h4 id="netstat">netstat</h4>
<pre><code>查询端口所占用的进程
netstat -ntulp | grep 10063
查询进程的详细信息
ps -ef|grep 4826
</code></pre><h4 id="telnet">telnet</h4>
<p>telnet命令通常用来远程登录。telnet程序是基于TELNET协议的远程登录客户端程序。  telnet因为采用明文传送报文，安全性不好，很多Linux服务器都不开放telnet服务，而改用更安全的ssh方式。</p>
<p>telnet命令除了远程登录，还被用于确定远程服务的状态，比如确定远程服务器的某个端口是否能访问</p>
<ul>
<li>命令格式</li>
</ul>
<pre><code>telnet[参数][HOST][PORT]
</code></pre><h4 id="du">du</h4>
<pre><code>du命令用来查看目录或文件所占用磁盘空间的大小
du常用的选项：
　　-h：以人类可读的方式显示
　　-a：显示目录占用的磁盘空间大小，还要显示其下目录和文件占用磁盘空间的大小
　　-s：显示目录占用的磁盘空间大小，不要显示其下子目录和文件占用的磁盘空间大小
　　-c：显示几个目录或文件占用的磁盘空间大小，还要统计它们的总和
　　--apparent-size：显示目录或文件自身的大小
　　-l ：统计硬链接占用磁盘空间的大小
　　-L：统计符号链接所指向的文件占用的磁盘空间大小　　

du -sh : 查看当前目录总共占的容量。而不单独列出各子项占用的容量 
du -lh --max-depth=1 : 查看当前目录下一级子文件和子目录占用的磁盘容量。
du -sh * | sort -n 统计当前文件夹(目录)大小，并按文件大小排序
du -sk filename 查看指定文件大小
</code></pre><h4 id="ln">ln</h4>
<p>为某一个文件在另外一个位置建立一个同步的链接。链接又可分为两种 : 硬链接(hard link)与软链接(symbolic link)，硬链接的
意思是一个档案可以有多个名称，而软链接的方式则是产生一个特殊的档案，该档案的内容是指向另一个档案的位置。硬链接是存在
同一个文件系统中，而软链接却可以跨越不同的文件系统。</p>
<pre><code>软链接：
1.软链接，以路径的形式存在。类似于Windows操作系统中的快捷方式
2.软链接可以 跨文件系统 ，硬链接不可以
3.软链接可以对一个不存在的文件名进行链接
4.软链接可以对目录进行链接

硬链接:
1.硬链接，以文件副本的形式存在。但不占用实际空间。
2.不允许给目录创建硬链接
3.硬链接只有在同一个文件系统中才能创建

ln命令会保持每一处链接文件的同步性
</code></pre><ul>
<li>格式</li>
</ul>
<pre><code>ln [参数][源文件或目录][目标文件或目录]
ln –s [源文件或目录][目标文件或目录] 软链接
ln [源文件或目录][目标文件或目录] 硬链接
</code></pre><h4 id="kill">kill</h4>
<p>Linux中的kill命令用来终止指定的进程的运行</p>
<ul>
<li>格式</li>
</ul>
<pre><code>kill[参数][进程号]
-l  信号，若果不加信号的编号参数，则使用“-l”参数会列出全部的信号名称
-a  当处理当前进程时，不限制命令名和进程号的对应关系
-p  指定kill 命令只打印相关进程的进程号，而不发送任何信号
-s  指定发送信号
-u  指定用户 
- 信号(默认终止信号(15))

全部信号：

kill -l
 1) SIGHUP	 2) SIGINT	 3) SIGQUIT	 4) SIGILL	 5) SIGTRAP
 6) SIGABRT	 7) SIGBUS	 8) SIGFPE	 9) SIGKILL	10) SIGUSR1
11) SIGSEGV	12) SIGUSR2	13) SIGPIPE	14) SIGALRM	15) SIGTERM
16) SIGSTKFLT	17) SIGCHLD	18) SIGCONT	19) SIGSTOP	20) SIGTSTP
21) SIGTTIN	22) SIGTTOU	23) SIGURG	24) SIGXCPU	25) SIGXFSZ
26) SIGVTALRM	27) SIGPROF	28) SIGWINCH	29) SIGIO	30) SIGPWR
31) SIGSYS	34) SIGRTMIN	35) SIGRTMIN+1	36) SIGRTMIN+2	37) SIGRTMIN+3
38) SIGRTMIN+4	39) SIGRTMIN+5	40) SIGRTMIN+6	41) SIGRTMIN+7	42) SIGRTMIN+8
43) SIGRTMIN+9	44) SIGRTMIN+10	45) SIGRTMIN+11	46) SIGRTMIN+12	47) SIGRTMIN+13
48) SIGRTMIN+14	49) SIGRTMIN+15	50) SIGRTMAX-14	51) SIGRTMAX-13	52) SIGRTMAX-12
53) SIGRTMAX-11	54) SIGRTMAX-10	55) SIGRTMAX-9	56) SIGRTMAX-8	57) SIGRTMAX-7
58) SIGRTMAX-6	59) SIGRTMAX-5	60) SIGRTMAX-4	61) SIGRTMAX-3	62) SIGRTMAX-2
63) SIGRTMAX-1	64) SIGRTMAX	

常用信号：

HUP    1    终端断线
INT     2    中断（同 Ctrl + C）
QUIT    3    退出（同 Ctrl + \）
TERM   15    终止
KILL    9    强制终止
CONT   18    继续（与STOP相反， fg/bg命令）
STOP    19    暂停（同 Ctrl + Z）
</code></pre><h4 id="watch">watch</h4>
<p>监测一个命令的运行结果</p>
<ul>
<li>命令格式</li>
</ul>
<pre><code>watch[参数][命令]
</code></pre><ul>
<li>命令参数</li>
</ul>
<pre><code>-n或--interval  watch缺省每2秒运行一下程序，可以用-n指定间隔的时间。
-d或--differences  用-d或--differences 选项watch 会高亮显示变化的区域。 而-d=cumulative选项会把变动过的地方(不管最近的那次有没有变动)都高亮显示出来。
-t 或-no-title  会关闭watch命令在顶部的时间间隔,命令，当前时间的输出。
</code></pre><ul>
<li>常用命令记录</li>
</ul>
<pre><code># 监测当file文件变化，频率5s，高亮显示
watch -n 5 -d'cat /file'
</code></pre><h4 id="alias">alias</h4>
<p>设置指令的别名。</p>
<ul>
<li>命令格式</li>
</ul>
<pre><code>alias[别名]=[指令名称]
</code></pre><ul>
<li>alias指令的有效期仅在于单次登录，可以在~/.bashrc(用户级别)或者/etc/bashrc(全局级别)文件追加配置登录指令</li>
</ul>
<pre><code>vim ~/.bashrc 
# 添加log路径的别名
alias cdlog=&quot;cd /data/log&quot;
# 让配置文件生效
source ~/.bashrc 
</code></pre><h4 id="nohup和后台运行">nohup和&amp;(后台运行)</h4>
<ul>
<li>nohup</li>
</ul>
<p>用途：不挂断地运行命令。</p>
<pre><code>语法：nohup Command [ Arg … ] [　&amp; ]

无论是否将 nohup 命令的输出重定向到终端，输出都将附加到当前目录的 nohup.out 文件中。
如果当前目录的 nohup.out 文件不可写，输出重定向到 $HOME/nohup.out 文件中。
如果没有文件能创建或打开以用于追加，那么 Command 参数指定的命令不可调用。
退出状态：该命令返回下列出口值： 　　
　　126 可以查找但不能调用 Command 参数指定的命令。 　　
　　127 nohup 命令发生错误或不能查找由 Command 参数指定的命令。 　　
　　否则，nohup 命令的退出状态是 Command 参数指定命令的退出状态。
</code></pre><ul>
<li>&amp;</li>
</ul>
<p>用途：在后台运行,一般和nohup两个一起用，nohup command &amp;</p>
<ul>
<li>SpringBoot例子</li>
</ul>
<pre><code>nohup java -jar xxx.jar &gt;bootstrap.log&amp;
</code></pre><h4 id="trap">trap</h4>
<p>trap作用是捕捉信号和其他事件并执行命令。</p>
<ul>
<li>命令格式</li>
</ul>
<pre><code>trap [-lp] [[arg] signal_spec ...]
</code></pre><ul>
<li>命令参数</li>
</ul>
<pre><code>-l    打印信号名称以及信号名称对应的数字。
-p    显示与每个信号关联的trap命令。
</code></pre><ul>
<li>常用命令</li>
</ul>
<pre><code># 当shell收到 HUP INT PIPE QUIT TERM 这几个命令时，当前执行的程序会执行 exit 1
trap &quot;exit 1&quot; HUP INT PIPE QUIT TERM
# 捕获Kill信号(SIGTERM 15)，执行方法_kill
trap _kill SIGTERM
</code></pre><h4 id="xargs">xargs</h4>
<p><code>xargs</code>命令的作用，是将标准输入转为命令行参数。</p>
<ul>
<li>命令格式</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"> xargs <span style="color:#f92672">[</span>-options<span style="color:#f92672">]</span> <span style="color:#f92672">[</span>command<span style="color:#f92672">]</span> 
</code></pre></div><ul>
<li>命令参数</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">-d 更改分隔符,如：
$ echo -e <span style="color:#e6db74">&#34;a\tb\tc&#34;</span> | xargs -d <span style="color:#e6db74">&#34;\t&#34;</span> echo
a b c

-p 打印出要执行的命令，询问用户是否要执行
-t 打印出最终要执行的命令
-L 指定多少行作为一个命令行参数
-n 指定每次将多少项，作为命令行参数
echo <span style="color:#f92672">{</span>0..9<span style="color:#f92672">}</span> | xargs -n <span style="color:#ae81ff">2</span> echo
<span style="color:#ae81ff">0</span> <span style="color:#ae81ff">1</span>
<span style="color:#ae81ff">2</span> <span style="color:#ae81ff">3</span>
<span style="color:#ae81ff">4</span> <span style="color:#ae81ff">5</span>
<span style="color:#ae81ff">6</span> <span style="color:#ae81ff">7</span>
<span style="color:#ae81ff">8</span> <span style="color:#ae81ff">9</span>

--max-procs xargs默认只用一个进程执行命令。如果命令要执行多次，必须等上一次执行完，才能执行下一次。--max-procs参数指定同时用多少个进程并行执行命令
</code></pre></div><ul>
<li>常用命令</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># 配合find使用</span>
find . -name <span style="color:#e6db74">&#39;datasource.properties&#39;</span> |xargs -t cat
</code></pre></div><h4 id="防火墙">防火墙</h4>
<p>centos7防火墙相关操作：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">1.查看已开放的端口<span style="color:#f92672">(</span>默认不开放任何端口<span style="color:#f92672">)</span>
firewall-cmd --list-ports
2.开启80端口
firewall-cmd --zone<span style="color:#f92672">=</span>public<span style="color:#f92672">(</span>作用域<span style="color:#f92672">)</span> --add-port<span style="color:#f92672">=</span>80/tcp<span style="color:#f92672">(</span>端口和访问类型<span style="color:#f92672">)</span> --permanent<span style="color:#f92672">(</span>永久生效<span style="color:#f92672">)</span>
firewall-cmd --zone<span style="color:#f92672">=</span>public --add-port<span style="color:#f92672">=</span>80/tcp --permanent
3.重启防火墙
firewall-cmd --reload
4.停止防火墙
systemctl stop firewalld.service
5.禁止防火墙开机启动
systemctl disable firewalld.service
6.删除
firewall-cmd --zone<span style="color:#f92672">=</span> public --remove-port<span style="color:#f92672">=</span>80/tcp --permanent

</code></pre></div><h4 id="其他">其他</h4>
<pre><code>如何删除大文件(正在写入的大文件)，会释放占用的磁盘
echo &quot;&quot; &gt; filename

查看文件的大小
du -ms filename
</code></pre><h3 id="处理数据相关">处理数据相关</h3>
<h4 id="排序sort">排序(sort)</h4>
<ul>
<li>命令格式</li>
</ul>
<pre><code>sort[选项][参数]

-b：忽略每行前面开始出的空格字符；
-c：检查文件是否已经按照顺序排序；
-d：排序时，处理英文字母、数字及空格字符外，忽略其他的字符；
-f：排序时，将小写字母视为大写字母；
-i：排序时，除了040至176之间的ASCII字符外，忽略其他的字符；
-m：将几个排序号的文件进行合并；
-M：将前面3个字母依照月份的缩写进行排序；
-n：依照数值的大小排序；
-o&lt;输出文件&gt;：将排序后的结果存入制定的文件；
-r：以相反的顺序来排序；
-t&lt;分隔字符&gt;：指定排序时所用的栏位分隔字符；
+&lt;起始栏位&gt;-&lt;结束栏位&gt;：以指定的栏位来排序，范围由起始栏位到结束栏位的前一栏位。
</code></pre><ul>
<li>示例</li>
</ul>
<pre><code># 统计当前文件夹(目录)大小，并按文件大小降序排序
du -sh * |sort -nr
</code></pre><h4 id="搜索数据grep">搜索数据(grep)</h4>
<p>文本搜索工具，用于过滤/搜索的特定字符,它能使用正则表达式搜索文本，并把匹配的行打印出来。</p>
<ul>
<li>命令格式</li>
</ul>
<pre><code>grep [option] pattern file

参数

-a   --text   #不要忽略二进制的数据。   
-A&lt;显示行数&gt;   --after-context=&lt;显示行数&gt;   #除了显示符合范本样式的那一列之外，并显示该行之后的内容。 
-b   --byte-offset   #在显示符合样式的那一行之前，标示出该行第一个字符的编号。 
-B&lt;显示行数&gt;   --before-context=&lt;显示行数&gt;   #除了显示符合样式的那一行之外，并显示该行之前的内容。   
-c    --count   #计算符合样式的列数。   
-C&lt;显示行数&gt;    --context=&lt;显示行数&gt;或-&lt;显示行数&gt;   #除了显示符合样式的那一行之外，并显示该行之前后的内容。   
-d &lt;动作&gt;      --directories=&lt;动作&gt;   #当指定要查找的是目录而非文件时，必须使用这项参数，否则grep指令将回报信息并停止动作。   
-e&lt;范本样式&gt;  --regexp=&lt;范本样式&gt;   #指定字符串做为查找文件内容的样式。   
-E      --extended-regexp   #将样式为延伸的普通表示法来使用。   
-f&lt;规则文件&gt;  --file=&lt;规则文件&gt;   #指定规则文件，其内容含有一个或多个规则样式，让grep查找符合规则条件的文件内容，格式为每行一个规则样式。   
-F   --fixed-regexp   #将样式视为固定字符串的列表。   
-G   --basic-regexp   #将样式视为普通的表示法来使用。   
-h   --no-filename   #在显示符合样式的那一行之前，不标示该行所属的文件名称。   
-H   --with-filename   #在显示符合样式的那一行之前，表示该行所属的文件名称。   
-i    --ignore-case   #忽略字符大小写的差别。   
-l    --file-with-matches   #列出文件内容符合指定的样式的文件名称。   
-L   --files-without-match   #列出文件内容不符合指定的样式的文件名称。   
-n   --line-number   #在显示符合样式的那一行之前，标示出该行的列数编号。   
-q   --quiet或--silent   #不显示任何信息。   
-r   --recursive   #此参数的效果和指定“-d recurse”参数相同。   
-s   --no-messages   #不显示错误信息。   
-v   --revert-match   #显示不包含匹配文本的所有行。   
-V   --version   #显示版本信息。   
-w   --word-regexp   #只显示全字符合的列。   
-x    --line-regexp   #只显示全列符合的列。   
-y   #此参数的效果和指定“-i”参数相同。

规则表达式

^  #锚定行的开始 如：'^grep'匹配所有以grep开头的行。    
$  #锚定行的结束 如：'grep$'匹配所有以grep结尾的行。    
.  #匹配一个非换行符的字符 如：'gr.p'匹配gr后接一个任意字符，然后是p。    
*  #匹配零个或多个先前字符 如：'*grep'匹配所有一个或多个空格后紧跟grep的行。    
.*   #一起用代表任意字符。   
[]   #匹配一个指定范围内的字符，如'[Gg]rep'匹配Grep和grep。    
[^]  #匹配一个不在指定范围内的字符，如：'[^A-FH-Z]rep'匹配不包含A-R和T-Z的一个字母开头，紧跟rep的行。    
\(..\)  #标记匹配字符，如'\(love\)'，love被标记为1。    
\&lt;      #锚定单词的开始，如:'\&lt;grep'匹配包含以grep开头的单词的行。    
\&gt;      #锚定单词的结束，如'grep\&gt;'匹配包含以grep结尾的单词的行。    
x\{m\}  #重复字符x，m次，如：'0\{5\}'匹配包含5个o的行。   
x\{m,\}  #重复字符x,至少m次，如：'o\{5,\}'匹配至少有5个o的行。    
x\{m,n\}  #重复字符x，至少m次，不多于n次，如：'o\{5,10\}'匹配5--10个o的行。   
\w    #匹配文字和数字字符，也就是[A-Za-z0-9]，如：'G\w*p'匹配以G后跟零个或多个文字或数字字符，然后是p。   
\W    #\w的反置形式，匹配一个或多个非单词字符，如点号句号等。   
\b    #单词锁定符，如: '\bgrep\b'只匹配grep。  
</code></pre><ul>
<li>常用案例</li>
</ul>
<pre><code># 文件关键字提取查找(info日志查询mongo)
cat info.log | grep -f mongo

# 查找指定进程
ps -ef|grep git

# 查找指定进程(不显示本身grep进程)
ps -ef | grep java | grep -v &quot;grep&quot;

# 从多个文件中查找关键字
grep 'mongodb' info1.log info2.log

# 找出mongo开头的行内容
cat info.log |grep ^mongo

# 找出mongo结尾的行内容
cat info.log |grep mongo$

# 显示包含api1或者cms1字符的内容行
cat info.log |grep -E &quot;api1|cms1&quot;
</code></pre><h4 id="压缩数据gzip">压缩数据(gzip)</h4>
<p>gzip是GNU压缩工具，用Lempel-Ziv编码压缩程序，压缩后使用&rdquo;.gz&quot;的扩展名</p>
<ul>
<li>命令格式</li>
</ul>
<pre><code>gzip[参数][文件或者目录]

参数

-a或--ascii 　使用ASCII文字模式。 
-c或--stdout或--to-stdout 　把压缩后的文件输出到标准输出设备，不去更动原始文件。 
-d或--decompress或----uncompress 　解开压缩文件。 
-f或--force 　强行压缩文件。不理会文件名称或硬连接是否存在以及该文件是否为符号连接。 
-h或--help 　在线帮助。 
-l或--list 　列出压缩文件的相关信息。 
-L或--license 　显示版本与版权信息。 
-n或--no-name 　压缩文件时，不保存原来的文件名称及时间戳记。 
-N或--name 　压缩文件时，保存原来的文件名称及时间戳记。 
-q或--quiet 　不显示警告信息。 
-r或--recursive 　递归处理，将指定目录下的所有文件及子目录一并处理。 
-S&lt;压缩字尾字符串&gt;或----suffix&lt;压缩字尾字符串&gt; 　更改压缩字尾字符串。 
-t或--test 　测试压缩文件是否正确无误。 
-v或--verbose 　显示指令执行过程。 
-V或--version 　显示版本信息。 
-num 用指定的数字num调整压缩的速度，-1或--fast表示最快压缩方法（低压缩比），-9或--best表示最慢压缩方法（高压缩比）。系统缺省值为6。 
</code></pre><ul>
<li>示例</li>
</ul>
<pre><code># 压缩文件
gzip info.log
# 解压目录
gzip -d info.log
# 递归压缩目录
gzip -rv api
# 递归解压目录
gzip -dr api
</code></pre><h4 id="归档数据tar">归档数据(tar)</h4>
<p>打包是指将一大堆文件或目录变成一个总的文件；压缩则是将一个大的文件通过一些压缩算法变成一个小文件。
由于Linux中很多压缩程序只能针对一个文件进行压缩，这样当你想要压缩一大堆文件时，你得先将这一大堆文件先打成一个包（tar命令），
然后再用压缩程序进行压缩（gzip命令）。</p>
<ul>
<li>命令格式</li>
</ul>
<pre><code>tar[必要参数][选择参数][文件] 

-A 新增压缩文件到已存在的压缩
-B 设置区块大小
-c 建立新的压缩文件
-d 记录文件的差别
-r 添加文件到已经压缩的文件
-u 添加改变了和现有的文件到已经存在的压缩文件
-x 从压缩的文件中提取文件
-t 显示压缩文件的内容
-z 支持gzip解压文件
-j 支持bzip2解压文件
-Z 支持compress解压文件
-v 显示操作过程
-l 文件系统边界设置
-k 保留原有文件不覆盖
-m 保留文件不被覆盖
-W 确认压缩文件的正确性

可选参数如下：

-b dir 设置区块数目
-C 切换到指定目录
-f file 指定压缩文件
--help 显示帮助信息
--version 显示版本信息

常见解压/压缩命令：

tar 
解包：tar xvf FileName.tar
打包：tar cvf FileName.tar DirName
（注：tar是打包）


.gz
解压1：gunzip FileName.gz
解压2：gzip -d FileName.gz
压缩：gzip FileName

.tar.gz 和 .tgz
解压：tar zxvf FileName.tar.gz
压缩：tar zcvf FileName.tar.gz DirName

.bz2
解压1：bzip2 -d FileName.bz2
解压2：bunzip2 FileName.bz2
压缩： bzip2 -z FileName

.tar.bz2
解压：tar jxvf FileName.tar.bz2
压缩：tar jcvf FileName.tar.bz2 DirName

.bz
解压1：bzip2 -d FileName.bz
解压2：bunzip2 FileName.bz
压缩：未知

.tar.bz
解压：tar jxvf FileName.tar.bz
压缩：未知

.Z
解压：uncompress FileName.Z
压缩：compress FileName

.tar.Z
解压：tar Zxvf FileName.tar.Z
压缩：tar Zcvf FileName.tar.Z DirName

.zip
解压：unzip FileName.zip
压缩：zip FileName.zip DirName

.rar
解压：rar x FileName.rar
压缩：rar a FileName.rar DirName 
</code></pre><ul>
<li>示例</li>
</ul>
<pre><code># 打包api1 api2目录
tar -cvf api.tar api1/ api2/
# 列除tar文件api.tar的内容，但不提取文件
tar -xvf api.tar
# 打包后，以 gzip 压缩 
tar -zcvf info.tar.gz info.log
# 查阅压缩后的tar包内有哪些文件
tar -ztvf log.tar.gz
# 解压缩tar包
tar -zxvf log.tar.gz
# 排除文件夹不进行打包 
tar --exclude api/service -zcvf api.tar.gz api/* 
</code></pre><h3 id="排查">排查</h3>
<h4 id="排查java-cpu占用问题">排查Java CPU占用问题</h4>
<p>1.0</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#75715e"># top命令，定位高CPU占用Java进程PID</span>
top -c <span style="color:#f92672">(</span>将系统资源使用情况实时显示出来<span style="color:#f92672">)</span> P<span style="color:#f92672">(</span>输入大写 P 将应用按照 CPU 使用率排序，第一个为使用率最高的<span style="color:#f92672">)</span>
<span style="color:#75715e"># 显示线程列表(查看占用CPU时间,占用时间，TID)</span>
ps -mp pid -o THREAD,tid,time
<span style="color:#75715e"># 将线程ID TID转换为16进制</span>
printf “%x<span style="color:#ae81ff">\n</span>” tid
<span style="color:#75715e"># 使用jstack打印线程堆栈信息(pid=进程id tid=我们转换的tid)</span>
.../jvm/jstack pid |grep tid -A <span style="color:#ae81ff">60</span>
</code></pre></div><p>2.0</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">1. top -c 将系统资源使用情况实时显示出来 （-c 参数可以完整显示命令）大写 P 将应用按照 CPU 使用率排序，第一个就是使用率最高的程序。
2.  top -Hp pid 然后输入 P 依然可以按照 CPU 使用率将线程排序。
3. 将线程ID TID转换为16进制printf “%x<span style="color:#ae81ff">\n</span>” tid。
4. 通过 jstack pid &gt;pid.log 生成日志文件，利用刚才保存的 <span style="color:#ae81ff">16</span> 进制进程 ID 去这个线程快照中搜索即可查看消耗 CPU 的线程日志。 
5. jstat -gcutil pid <span style="color:#ae81ff">200</span> <span style="color:#ae81ff">50</span> 将内存使用、gc 回收状况打印出来（每隔 200ms 打印 50次）。
6. 
</code></pre></div><h4 id="排查java高内存占用问题">排查Java高内存占用问题</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#75715e"># 查看当前Java进程创建的活跃对象数目和占用内存大小</span>
jmap -histo:live <span style="color:#f92672">[</span>pid<span style="color:#f92672">]</span> &gt;a.log
<span style="color:#75715e"># 当前Java进程的内存占用情况导出来，方便用专门的内存分析工具（例如：MAT）来分析。</span>
jmap -dump:live,format<span style="color:#f92672">=</span>b,file<span style="color:#f92672">=</span>xxx.xxx <span style="color:#f92672">[</span>pid<span style="color:#f92672">]</span>
</code></pre></div><h3 id="阿里云相关">阿里云相关</h3>
<h4 id="挂载ecs数据盘">挂载ecs数据盘</h4>
<ul>
<li>先将数据盘挂载到实例上</li>
<li>分区</li>
</ul>
<pre><code>fdisk /dev/vdb
Command n [新建分区]
Command p [选择分区类型为主分区]
Selected partition 1 [选择分区号]
Command w [退出]
</code></pre><ul>
<li>格式化</li>
</ul>
<pre><code>mkfs.ext4 /dev/vdb1
</code></pre><ul>
<li>修改 /etc/fstab</li>
</ul>
<pre><code>cp /etc/fstab /etc/fstab.bak

mkdir -p /data
echo /dev/vdb1 /data ext4 defaults 0 0 &gt;&gt; /etc/fstab
</code></pre><ul>
<li>将分区挂载到对应的文件系统路径下</li>
</ul>
<pre><code>mount /dev/vdb1 /data
</code></pre><h4 id="阿里云数据盘扩容操作">阿里云数据盘扩容操作</h4>
<ul>
<li>控制台操作对数据盘进行扩容</li>
<li>重启机器</li>
<li>确认分区和文件系统</li>
</ul>
<pre><code># 确认磁盘是否分区(fdisk -lu &lt;DeviceName&gt;)
fdisk -lu /dev/vdb

展示如下:
Device Boot      Start         End      Blocks   Id  System
/dev/vdb1              63  1048575023   524287480+  83  Linux

# 确认文件系统(blkid &lt;PartionName&gt;)
blkid /dev/vdb1

/dev/vdb1: UUID=&quot;...&quot; TYPE=&quot;ext4&quot;

# 确认文件系统状态为clean
e2fsck -n /dev/vdb1
</code></pre><ul>
<li>卸载数据盘(原先/dev/vdb1是挂载到/data的)</li>
</ul>
<pre><code>umount /data
</code></pre><ul>
<li>扩展已有分区</li>
</ul>
<pre><code># 显示并记录旧分区的起始和结束的扇区位置
fdisk -lu /dev/vdb

# 删除旧分区
fdisk -u /dev/vdb
Command p [打印分区表]
Command d [删除分区]
Selected partition 1 [选择分区号]
Command w [退出]

# 新建分区
fdisk -u /dev/vdb
Command p [打印分区表]
Command n [新建分区]
Command p [选择分区类型为主分区]
Selected partition 1 [选择分区号]
Command w [退出]

# lsblk /dev/vdb确认分区表,显示如下 500G-&gt;1000G
NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
vdb    252:16   0 1000G  0 disk 
└─vdb1 252:17   0 1000G  0 part 

# 确认文件系统状态为clean
e2fsck -n /dev/vdb1

# 内核版本 ≥ 3.6的，通知内核更新分区表
partprobe &lt;dst_dev_path&gt;或者partx -u &lt;dst_dev_path&gt;
</code></pre><ul>
<li>扩容文件系统</li>
</ul>
<pre><code># 检测并修复文件系统的完整性
e2fsck -f /dev/vdb1

# 增大文件系统的大小
resize2fs -f /dev/vdb1

# 重新挂载/data
mount /dev/vdb1 /data
</code></pre><h3 id="centos环境相关配置">Centos环境相关配置</h3>
<h4 id="docker">Docker</h4>
<pre><code># 查看当前的内核版本(需要3.1.0以上版本)
uname -r

# 更新yum包
sudo yum update

# 安装需要的软件包
sudo yum install -y yum-utils device-mapper-persistent-data lvm2

# 设置yum源
sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo

# 可以查看所有仓库中所有docker版本，并选择特定版本安装
yum list docker-ce --showduplicates | sort -r

# 安装docker
sudo yum install docker-ce
sudo yum install &lt;FQPN docker-ce.x86_64 3:19.03.5-3.el7&gt;

# 启动并加入开机启动
sudo systemctl start docker
sudo systemctl enable docker

# 验证
docker version

# 命令
sudo systemctl stop docker
sudo systemctl start docker

# 镜像加速器
## 七牛云加速器 https://reg-mirror.qiniu.com/Azure 中国镜像 https://dockerhub.azk8s.cn

vim /etc/docker/daemon.json

## 加入镜像地址

{
  &quot;registry-mirrors&quot;: [
    &quot;https://dockerhub.azk8s.cn&quot;,
    &quot;https://reg-mirror.qiniu.com&quot;
  ]
}

## 重启服务
sudo systemctl daemon-reload
sudo systemctl restart docker

## docker info查看Registry Mirrors配置
</code></pre><h4 id="openjdk18">OpenJDK1.8</h4>
<pre><code>yum -y install java-1.8.0-openjdk java-1.8.0-openjdk-devel

# 获取java home
dirname $(readlink $(readlink $(which java))) 

# 设置环境变量
vim /etc/profile.d/env_export.sh
export JAVA_HOME=上面dirname命令获取到的路径，去掉/jre/bin最后这段
export PATH=$PATH:$JAVA_HOME/bin
export CLASSPATH=.:$JAVA_HOME/jre/lib:$JAVA_HOME/lib:$JAVA_HOME/lib/tools.jar

# 使设置立即生效
source /etc/profile.d/env_export.sh
</code></pre><h4 id="nginx">Nginx</h4>
<pre><code># 配置 EPEL源
sudo yum install -y epel-release
sudo yum -y update

# 安装Nginx
sudo yum install -y nginx

# 常用命令
systemctl enable nginx.service	设置开机启动
systemctl disable nginx.service	停止开机自启动
systemctl start nginx.service	启动nginx服务
systemctl status nginx.service	查看服务当前状态
systemctl restart nginx.service	重新启动服务
systemctl list-units --type=service	查看所有已启动的服务

nginx -s reload
nginx -s stop
nginx -s quit
nginx -t
service nginx start
</code></pre><h4 id="mongodb">mongoDB</h4>
<pre><code># 配置MongoDB的yum源
#cd /etc/yum.repos.d 
#vim mongodb-org-4.2.repo

# 添加阿里云源

[mngodb-org]
name=MongoDB Repository
baseurl=http://mirrors.aliyun.com/mongodb/yum/redhat/7Server/mongodb-org/4.0/x86_64/
gpgcheck=0
enabled=1

# 安装
yum install -y mongodb-org

# 常用命令

/usr/bin/mongod --config /etc/mongod.conf #启动
/usr/bin/mongod --shutdown --config /etc/mongod.conf #停止
mongo 						#进入控制台
</code></pre><h4 id="maven">maven</h4>
<pre><code># 下载maven
wget http://mirrors.tuna.tsinghua.edu.cn/apache/maven/maven-3/3.3.9/binaries/apache-maven-3.3.9-bin.tar.gz

# 解压安装
tar -zxvf apache-maven-3.3.9-bin.tar.gz 

# 配置环境变量
vim /etc/profile

M2_HOME=/opt/tools/apache-maven-3.3.9
export PATH=${M2_HOME}/bin:${PATH}

# 重载/etc/profile
source /etc/profile
</code></pre><h4 id="nodejs">Node.js</h4>
<pre><code># 确认系统是否已经安装了epel-release包
yum info epel-release
# 安装epel-release
yum install epel-release
# 安装node.js
sudo yum install nodejs
# 安装n（node 版本管理器）
npm install -g n
# 安装最新版本
n latest
# 安装指定版本
n 8.11.3
# 选择已安装的版本
n
</code></pre><h4 id="其他-1">其他</h4>
<pre><code># 修改主机名
hostnamectl set-hostname name

# 修改ssh端口
vim /etc/ssh/sshd_config（修改Port值）
</code></pre><h3 id="链接">链接</h3>
<p><a href="https://www.cnblogs.com/peida/tag/%E6%AF%8F%E6%97%A5%E4%B8%80linux%E5%91%BD%E4%BB%A4/">每日一linux命令</a></p>


      
        <div class="blog-tags">
          
            <a
              href="https://chinalhr.github.io/tags/linux/"
              >Linux</a
            >&nbsp;
          
        </div>
      
    </article>
    
      <script>
  document.addEventListener('scroll', function () {
    if (
      document.body.scrollTop > 50 ||
      document.documentElement.scrollTop > 50
    ) {
      document.getElementById('backtotopButton').style.opacity = '1'
      document.getElementById('backtotopButton').style.transition = '0.5s'
    } else {
      document.getElementById('backtotopButton').style.opacity = '0'
      document.getElementById('backtotopButton').style.transition = '0.5s'
    }
  })

  function topFunction() {
    document.body.scrollTop = 0 
    document.documentElement.scrollTop = 0 
  }
</script>

      <button onclick="topFunction()" id="backtotopButton">
        <em class="fa fa-angle-up"></em>
      </button>
    
    
      

    
  </div>

    <footer>
  

<div class="social-icons">
  
    
    
      
      <a href="https://github.com/chinalhr" name="GitHub">
        <em class="fab fa-github"></em>
      </a>
    
       &nbsp;&ndash;&nbsp;
      <a href="mailto:13435500980@163.com" name="Email">
        <em class="fas fa-envelope"></em>
      </a>
    
  

  
</div>


  
  <div class="container">
    <p class="credits copyright">
      <a href="https://chinalhr.github.io/about">hanrong.li</a>
      &nbsp;&copy;
      2022
      
        &nbsp;/&nbsp;
        <a href="https://chinalhr.github.io/">ChinaLHR Blog</a>
      
      &nbsp;&ndash;&nbsp;
      <em class="fas fa-moon" id="dark-mode-toggle"></em>
    </p>

    <p class="credits theme-by">
      Powered By <a href="https://gohugo.io">Hugo</a>&nbsp;
      Theme
      <a href="https://github.com/matsuyoshi30/harbor">Harbor</a>
    </p>
  </div>
</footer>

  </body>
</html>
