<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
<title>Kotlin基础：类型系统、语言特性</title>
<meta name="description"
      content=""
>

  
    
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-JLJBQBW5WM"></script>
    <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-JLJBQBW5WM');
  </script>
  




<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<link
  rel="alternate"
  type="application/rss+xml"
  href="https://chinalhr.github.io/index.xml"
  title="ChinaLHR Blog"
/>
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Kotlin基础：类型系统、语言特性"/>
<meta name="twitter:description" content="
Kotlin学习记录
"/>



<link rel="stylesheet" href="https://chinalhr.github.io/fontawesome/css/all.min.css" />




<link
  crossorigin="anonymous"
  href="/css/styles.min.css"
  integrity=""
  rel="preload stylesheet"
  as="style"
/>




<link
  id="dark-mode-theme"
  crossorigin="anonymous"
  href="/css/dark.min.css"
  integrity=""
  rel="preload stylesheet"
  as="style"
/>


<script>
  var darkTheme = document.getElementById('dark-mode-theme')
  var storedTheme = localStorage.getItem('dark-mode-storage')

  if (storedTheme === 'dark') {
    darkTheme.disabled = false
  } else if (storedTheme === 'light') {
    darkTheme.disabled = true
  }
</script>


<script defer crossorigin="anonymous" src="/js/theme.js" integrity=""></script>


<script defer crossorigin="anonymous" src="/js/instantpage.min.js" integrity=""></script><meta name="generator" content="Hugo 0.68.3" />
  </head>
  <body>
    
  




  <header>
    <nav class="navbar">
  <div class="nav">
    
      <a href="https://chinalhr.github.io/" class="nav-logo">
        <img
          src="https://chinalhr.github.io/images/icon.png"
          width="50"
          height="50"
          alt="Logo"
        />
      </a>
    

    <ul class="nav-links">
      
        
          <li>
            <a href="/about/" id="About"
              ><em class="fas fa-user fa-lg"></em
            ></a>
          </li>
          
      
        
          <li>
            <a href="/categories/" id="Categories"
              ><em class="fas fa-filter fa-lg"></em
            ></a>
          </li>
          
      
        
          <li>
            <a href="/tags/" id="Tags"
              ><em class="fas fa-tags fa-lg"></em
            ></a>
          </li>
          
      
        
          <li>
            <a href="/archives/" id="Archives"
              ><em class="fas fa-archive fa-lg"></em
            ></a>
          </li>
          
      
        
          <li>
            <a href="/search/" id="Search"
              ><em class="fas fa-search fa-lg"></em
            ></a>
          </li>
          
      
    </ul>
  </div>
</nav>

    <div class="intro-header">
      <div class="container">
        <div class="post-heading">
          
            <h1>
              Kotlin基础：类型系统、语言特性
            </h1>
          
          
            <span class="meta-post">
  <em class="fa fa-calendar-alt"></em
  >&nbsp;Feb 27, 2019
  
    &nbsp;&nbsp;&nbsp;<em class="fa fa-folder-open"></em>&nbsp;
    
      <a
        href="https://chinalhr.github.io/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"
        >后端开发</a
      >&nbsp;
    
  
</span>

          
        </div>
      </div>
    </div>
  </header>
  

    
  <div class="container" role="main">
    <article class="article" class="blog-post">
      <blockquote>
<p>Kotlin学习记录</p>
</blockquote>
<h3 id="可null性">可Null性</h3>
<p><strong>java类型系统缺陷</strong>：</p>
<p>例如String类型的变量可以持有两种值，分别是String的实例和 null，但两种值完全不一样(instanceof 运算符null不是String)。类型系统的缺陷导致即使变量拥有声明的类型 String你依然无法知道能对该变量的值做些什么，除非做额外的检查。</p>
<p>Kotlin解决NullPointerException之道：把运行时的错误转变成编译期的错误</p>
<ul>
<li>
<p>编译器强制检测变量实参,所有常见类型默认都是非空的,可以在任何类型的后面加?来表示这个类型的变量可以存储 null 引用。<strong>但是对可null参数进行的操作也会受到限制，需要对可null参数进行null处理(判断，安全符&hellip;)才可以编译通过。</strong></p>
</li>
<li>
<p>Java 中的类型在Kotlin中被解释成平台类型，允许开发者把它们当作可空或非空来对待。</p>
</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">strLen</span>(s: String?) = s<span style="color:#f92672">?.</span>length
</code></pre></div><ul>
<li>安全运算符
<strong>?. 和 ?: 安全Null运算符</strong></li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#75715e">/**
</span><span style="color:#75715e"> * ?.把一次 null 检查和一次方法调用合并成一个操作
</span><span style="color:#75715e"> * 下面两个函数是等效的
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">strLen</span>(s: String?) = s<span style="color:#f92672">?.</span>length

<span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">strLenOld</span>(s: String?) = {
    <span style="color:#66d9ef">if</span> (s != <span style="color:#66d9ef">null</span>) s.length <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">null</span>
}

<span style="color:#75715e">/**
</span><span style="color:#75715e"> * Elvis 运算符 代替 null 的默认值，也可配合throw食用
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">val</span> t: String = s <span style="color:#f92672">?:</span> <span style="color:#e6db74">&#34;&#34;</span>

<span style="color:#66d9ef">val</span> t: String = s <span style="color:#f92672">?:</span> <span style="color:#66d9ef">throw</span> IllegalArgumentException(<span style="color:#e6db74">&#34;String is null&#34;</span>)

<span style="color:#75715e">/**
</span><span style="color:#75715e"> * 链式安全调用
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Address</span>(<span style="color:#66d9ef">val</span> streetAddress: String, <span style="color:#66d9ef">val</span> zipCode: Int, <span style="color:#66d9ef">val</span> city: String, <span style="color:#66d9ef">val</span> country: String)
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Company</span>(<span style="color:#66d9ef">val</span> name: String, <span style="color:#66d9ef">val</span> address: Address ? )
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Person</span>(<span style="color:#66d9ef">val</span> name: String, <span style="color:#66d9ef">val</span> company: Company?)

<span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">Person</span>.countryName() :String{
    <span style="color:#66d9ef">val</span> companyStr = <span style="color:#66d9ef">this</span>.company<span style="color:#f92672">?.</span>address<span style="color:#f92672">?.</span>country
    <span style="color:#66d9ef">return</span> companyStr<span style="color:#f92672">?:</span><span style="color:#e6db74">&#34;UnKnow&#34;</span>
}
</code></pre></div><p><strong>as? 安全类型转换运算符</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#75715e">/**
</span><span style="color:#75715e"> * as? 尝试把值转换成指定的类型， 如果值不是合适的类型就返回 null
</span><span style="color:#75715e"> * 配合Elvis 运算符
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">val</span> otherPerson = o <span style="color:#66d9ef">as</span>? Person<span style="color:#f92672">?:</span> <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>
</code></pre></div><p><strong>非Null断言!!</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#75715e">/**
</span><span style="color:#75715e"> * !!可以把任何值转换成非空类型。如果对 null 值做非空断言，则会抛出异常。
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">ignoreNulls</span>(s: String?) {
    <span style="color:#66d9ef">val</span> sNotNullVal = s<span style="color:#f92672">!!</span> <span style="color:#75715e">//如果s为null,此处抛出KotlinNullPointerException异常
</span><span style="color:#75715e"></span>    println(sNotNullVal)
}
</code></pre></div><p><strong>let</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#75715e">/**
</span><span style="color:#75715e"> * let:允许你对表达式求值，检查求值结果是否为 null ,并把结果保存为一个变量
</span><span style="color:#75715e"> * 只在表达式不为 null 时执行 lambda,相当于
</span><span style="color:#75715e"> * if (email != null)  sendEmailTo(email)
</span><span style="color:#75715e"> */</span>
email<span style="color:#f92672">?.</span>let { email -&gt; sendEmailTo(email) }
</code></pre></div><p><strong>lateinit 延迟初始化</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#75715e">/**
</span><span style="color:#75715e"> * 不需要在构造方法中初始化它。如果在属性被初始化之前就访问了它，会抛出异常
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">private</span> <span style="color:#66d9ef">lateinit</span> <span style="color:#66d9ef">var</span> myService: MyService
</code></pre></div><ul>
<li>Kotlin与Java Null操作
Java 的类型系统是不支持可空性的</li>
</ul>
<p>Kotlin注解转换：Java 中的@ Nullable String 被 Kotlin 当作 String?,而@NotNull String 就是String</p>
<p>Kotlin编译器无法对Java的可Null类型检测，开发者负责正确处理来自 Java 的值。</p>
<h3 id="数据类型">数据类型</h3>
<ul>
<li>对比Java</li>
</ul>
<p>整数类型 Byte  Short Int Long
浮点数类型 Float Double
字符类型 Char
布尔类型 Boolean</p>
<p>对比Java，Kotlin不区分基本数据类型和它们的包装类。对于变量、属性、参数和返回类型Kotlin编译器会尽可能编译为基本类型，除了泛型。</p>
<p>Kotiin不会自动地把数字从一种类型转换成另外一种，即便是转换成范围更大的类型。可以使用支持双向转换的函数,toByte(),toShort()&hellip; Kotlin 要求转换必须是显式的，可以避免转换数值的问题。</p>
<ul>
<li>
<p>根类型&rsquo;Any&rsquo; &lsquo;Any?&rsquo;
Any类型是Kotiin所有非空类型的超类型，包括基础类型,区别于Java Object 只是所有引用类型的超类型，非基础类型</p>
</li>
<li>
<p>Unit 类型 和 Nothing 类型
Unit是Kotlin 的 &lsquo;void&rsquo; ，区别是Unit是一个完备的类型，可以作为类型参数。只存在一个值是 Unit 类型，这个值也叫作 Unit，并且（在函数中）会被隐式地返回。</p>
</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#75715e">//下面两个函数等效
</span><span style="color:#75715e"></span><span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">f</span> () : Unit { . . . }
<span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">f</span> () { .. }

<span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Processor</span>&lt;T&gt; {
    <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">process</span>(): T
}

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">NoResultProcessor</span> : Processor&lt;Unit&gt;{
    <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">process</span>() {
        <span style="color:#75715e">//不需要显示return 会隐式返回Unit
</span><span style="color:#75715e"></span>    }
}
</code></pre></div><p>Nothing 类型没有任何值,只有被当作函数返回值使用,表示函数永不返回</p>
<ul>
<li>集合数组</li>
</ul>
<p><strong>集合</strong></p>
<p>List&lt;Int?&gt; : 列表中的单个值是可Null的 <!-- raw HTML omitted -->
List<!-- raw HTML omitted -->? : 集合本身是可Null的,但列表中的元素保证是非空的 <!-- raw HTML omitted -->
List&lt;Int?&gt;? :集合本身是可Null的,列表中的单个值是可Null的</p>
<p>可以使用filterNotNull()函数过滤集合</p>
<p><strong>只读集合，可变集合</strong></p>
<p>对比Java,Kotlin把访问集合数据的接口和修改集合数据的接口分开了。Collection接口(读)，MutableCollection接口(写)</p>
<p>优势:让程序 中的数据发生的事情更容易理解，根据入参类型是可读或者可写的，很容易实现防御性编程，</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">fun</span>&lt;T&gt; copyElements(source:Collection&lt;T&gt;,target:MutableCollection&lt;T&gt;){
    <span style="color:#66d9ef">for</span> (item <span style="color:#66d9ef">in</span> source){
        target.add(item)
    }
}
</code></pre></div><p><strong>数组</strong></p>
<p>Kotiin 中的一个数组是一个带有类型参数的类Array，其元素类型被指定为相应的类型参数。基本数据类型的数组使用像 IntArray 这样的特殊类来表示 。</p>
<h3 id="语言特性-约定">语言特性-约定</h3>
<h4 id="重载">重载</h4>
<ul>
<li>二元运算符重载</li>
</ul>
<table>
<thead>
<tr>
<th>表达式</th>
<th>函数名</th>
</tr>
</thead>
<tbody>
<tr>
<td>a * b</td>
<td>times</td>
</tr>
<tr>
<td>a / b</td>
<td>div</td>
</tr>
<tr>
<td>a % b</td>
<td>mod</td>
</tr>
<tr>
<td>a + b</td>
<td>plus</td>
</tr>
<tr>
<td>a - b</td>
<td>minus</td>
</tr>
</tbody>
</table>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#75715e">/**
</span><span style="color:#75715e"> * 定义一个名为plus的方法，operator重载+号运算符(扩展函数)
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">operator</span> <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">Point</span>.plus(other: Point): Point {
    <span style="color:#66d9ef">return</span> Point(x + other.x, y + other.y)
}

<span style="color:#66d9ef">data</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Point</span>(<span style="color:#66d9ef">val</span> x: Int, <span style="color:#66d9ef">val</span> y: Int)

<span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">main</span>(args: Array&lt;String&gt;) {
    <span style="color:#66d9ef">val</span> p1 = Point(<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">20</span>)
    <span style="color:#66d9ef">val</span> p2 = Point(<span style="color:#ae81ff">30</span>, <span style="color:#ae81ff">40</span>)
    println(p1 + p2)
}
    
</code></pre></div><ul>
<li>一元运算符重载</li>
</ul>
<p>用于重载一元运算符的函数，没有任何参数。</p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>函数名</th>
</tr>
</thead>
<tbody>
<tr>
<td>+a</td>
<td>unaryPlus</td>
</tr>
<tr>
<td>-a</td>
<td>unaryMinus</td>
</tr>
<tr>
<td>!a</td>
<td>not</td>
</tr>
<tr>
<td>++a,a++</td>
<td>inc</td>
</tr>
<tr>
<td>&ndash;a,a&ndash;</td>
<td>dec</td>
</tr>
</tbody>
</table>
<ul>
<li>比较运算符重载
如果在 Kotiin 中使用＝＝(!=)运算符，它将被转换成 equals(!equals) 方法的调用。===恒等于等效于Java的==。</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">data</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Point</span>(<span style="color:#66d9ef">val</span> x: Int, <span style="color:#66d9ef">val</span> y: Int){
    <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">equals</span>(obj: Any?): Boolean {
        <span style="color:#66d9ef">if</span>(obj === <span style="color:#66d9ef">this</span>) <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span> <span style="color:#75715e">//引用检测
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (obj !<span style="color:#66d9ef">is</span> Point) <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span><span style="color:#75715e">//类型检测
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> obj.x == x &amp;&amp; obj.y == y
    }
}
</code></pre></div><ul>
<li>重载(下标访问get/set),in,rangeTo,iterator</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">operator</span> <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">Point</span>.<span style="color:#66d9ef">get</span>(index: Int):Int{
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">when</span>(index){
        <span style="color:#ae81ff">0</span> -&gt; x
        <span style="color:#ae81ff">1</span> -&gt; y
        <span style="color:#66d9ef">else</span> -&gt; <span style="color:#66d9ef">throw</span> IndexOutOfBoundsException(<span style="color:#e6db74">&#34;Invalid coordinate $index&#34;</span>)
    }
}

<span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">main</span>(args: Array&lt;String&gt;) {
    <span style="color:#66d9ef">val</span> p1 = Point(<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">20</span>)
    println(<span style="color:#e6db74">&#34;p1 x-&gt; ${p1[0]}y-&gt; ${p1[1]}&#34;</span>)
}
</code></pre></div><h4 id="解构声明和组件函数">解构声明和组件函数</h4>
<p>解构声明允许你展开单个复合值，并使用它来初始化多个单独的变量。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#75715e">/**
</span><span style="color:#75715e"> * 数据类持有类型
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">data</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">NamesComponents</span>(<span style="color:#66d9ef">val</span> name: String, <span style="color:#66d9ef">val</span> ext: String)

<span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">splitFilename</span>(fullName: String): NamesComponents {
    <span style="color:#66d9ef">val</span> reslut = fullName.split(<span style="color:#e6db74">&#34;.&#34;</span>, limit = <span style="color:#ae81ff">2</span>)
    <span style="color:#66d9ef">return</span> NamesComponents(reslut[<span style="color:#ae81ff">0</span>], reslut[<span style="color:#ae81ff">1</span>])
}

<span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">main</span>(args: Array&lt;String&gt;) {
    <span style="color:#75715e">//解构声明展开类
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">val</span> <span style="color:#960050;background-color:#1e0010">(</span>name, ext) = splitFilename(<span style="color:#e6db74">&#34;ext.so&#34;</span>)
    println(<span style="color:#e6db74">&#34;name:$name ext $ext&#34;</span>)
}
</code></pre></div><p>解构声明可用于集合循环</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">for</span> (entry <span style="color:#66d9ef">in</span> map.entries) {
<span style="color:#66d9ef">val</span> key = entry. cornponentl()
<span style="color:#66d9ef">val</span> value= entry.cornponent2()
}
</code></pre></div><h4 id="委托属性">委托属性</h4>
<p>委托模式，这个模式应用于一个属性时，它也可以将访问器的逻辑委托给一个辅助对象。Kotlin中关键宇by可以用于任何符合属性委托约定规则的对象。</p>
<p>用处：Observable，Listener(编译器自动实现代码)Delegates.observable 函数可以用来添加属性更改的观察者</p>
<ul>
<li>委托属性</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Foo</span> {
<span style="color:#75715e">// 对p的get/set操作调用对应Delegate的get/setValue
</span><span style="color:#75715e"></span><span style="color:#66d9ef">var</span> p: Type <span style="color:#66d9ef">by</span> Delegate ()
}

<span style="color:#75715e">//委托属性应用:存储到MySql/Map
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Person</span> {
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">val</span> _attributes = hashMapOf&lt;String, String&gt; ()
    
    <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">setAttribute</span>(attrName: String, value: String) {
        -attributes[attrName] =value
    }
    <span style="color:#75715e">//将map(_attributes) 作为委托属性 set/get name自动存储到Map
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">val</span> name: String <span style="color:#66d9ef">by</span> _attributes 
}
</code></pre></div><ul>
<li>惰性初始化
相比java的if(obj==null){//初始化并返回}else{//直接返回}，Kotlin可以更简单做到</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Person</span>(<span style="color:#66d9ef">val</span> name:String){
    <span style="color:#66d9ef">val</span> email <span style="color:#66d9ef">by</span> lazy { loadEmail(<span style="color:#66d9ef">this</span>) }

}
</code></pre></div>


      
        <div class="blog-tags">
          
            <a
              href="https://chinalhr.github.io/tags/kotlin/"
              >Kotlin</a
            >&nbsp;
          
        </div>
      
    </article>
    
      <button onclick="topFunction()" id="backtotopButton">
        <em class="fa fa-angle-up"></em>
      </button>
      <script>
  var backtotopButton = document.getElementById('backtotopButton')

  document.addEventListener('scroll', function () {
    if (
      document.body.scrollTop > 50 ||
      document.documentElement.scrollTop > 50
    ) {
      backtotopButton.style.opacity = '1'
    } else {
      backtotopButton.style.opacity = '0'
    }
  })

  function topFunction() {
    document.body.scrollTop = 0 
    document.documentElement.scrollTop = 0 
  }

  
  document.dispatchEvent(new CustomEvent('scroll'))
  backtotopButton.style.display = 'block'
</script>

    
    
      

    
  </div>

    <footer>
  

<div class="social-icons">
  
    
    
      
      <a href="https://github.com/chinalhr" name="GitHub">
        <em class="fab fa-github"></em>
      </a>
    
       &nbsp;&ndash;&nbsp;
      <a href="mailto:13435500980@163.com" name="Email">
        <em class="fas fa-envelope"></em>
      </a>
    
  

  
</div>


  
  <div class="container">
    <p class="credits copyright">
      <a href="https://chinalhr.github.io/about">hanrong.li</a>
      &nbsp;&copy;
      2022
      
        &nbsp;/&nbsp;
        <a href="https://chinalhr.github.io/">ChinaLHR Blog</a>
      
      &nbsp;&ndash;&nbsp;
      <em class="fas fa-moon" id="dark-mode-toggle"></em>
    </p>

    <p class="credits theme-by">
      Powered By <a href="https://gohugo.io">Hugo</a>&nbsp;
      Theme
      <a href="https://github.com/matsuyoshi30/harbor">Harbor</a>
    </p>
  </div>
</footer>

  </body>
</html>
