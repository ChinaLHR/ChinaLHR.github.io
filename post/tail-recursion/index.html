<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
<title>尾递归-Java-Kotlin</title>


  




<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<link
  rel="alternate"
  type="application/rss+xml"
  href="https://chinalhr.github.io/index.xml"
  title="ChinaLHR Blog"
/>
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="尾递归-Java-Kotlin"/>
<meta name="twitter:description" content="
尾递归与递归的对比，以及在Java与Kotlin中如何运用
"/>



<link rel="stylesheet" href="https://chinalhr.github.io/fontawesome/css/all.min.css" />




<link
  crossorigin="anonymous"
  href="/css/styles.min.css"
  integrity=""
  rel="preload stylesheet"
  as="style"
/>




<link
  id="dark-mode-theme"
  crossorigin="anonymous"
  href="/css/dark.min.css"
  integrity=""
  rel="preload stylesheet"
  as="style"
/>


<script>
  var darkTheme = document.getElementById('dark-mode-theme')
  var storedTheme = localStorage.getItem('dark-mode-storage')

  if (storedTheme === 'dark') {
    darkTheme.disabled = false
  } else if (storedTheme === 'light') {
    darkTheme.disabled = true
  }
</script>


<script defer crossorigin="anonymous" src="/js/theme.js" integrity=""></script>


<script defer crossorigin="anonymous" src="/js/instantpage.min.js" integrity=""></script><meta name="generator" content="Hugo 0.68.3" />
  </head>
  <body>
    
  




  <header>
    <nav class="navbar">
  <div class="nav">
    
      <a href="https://chinalhr.github.io/" class="nav-logo">
        <img
          src="https://chinalhr.github.io/images/icon.png"
          width="50"
          height="50"
          alt="Logo"
        />
      </a>
    

    <ul class="nav-links">
      
        
          <li>
            <a href="/about/" id="About"
              ><em class="fas fa-user fa-lg"></em
            ></a>
          </li>
          
      
        
          <li>
            <a href="/categories/" id="Categories"
              ><em class="fas fa-filter fa-lg"></em
            ></a>
          </li>
          
      
        
          <li>
            <a href="/tags/" id="Tags"
              ><em class="fas fa-tags fa-lg"></em
            ></a>
          </li>
          
      
        
          <li>
            <a href="/archives/" id="Archives"
              ><em class="fas fa-archive fa-lg"></em
            ></a>
          </li>
          
      
        
          <li>
            <a href="/search/" id="Search"
              ><em class="fas fa-search fa-lg"></em
            ></a>
          </li>
          
      
    </ul>
  </div>
</nav>

    <div class="intro-header">
      <div class="container">
        <div class="post-heading">
          
            <h1>
              尾递归-Java-Kotlin
            </h1>
          
          
            <span class="meta-post">
  <em class="fa fa-calendar-alt"></em
  >&nbsp;Aug 4, 2019
  
    &nbsp;&nbsp;&nbsp;<em class="fa fa-folder-open"></em>&nbsp;
    
      <a
        href="https://chinalhr.github.io/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/"
        >编程技巧</a
      >&nbsp;
    
  
</span>

          
        </div>
      </div>
    </div>
  </header>
  

    
  <div class="container" role="main">
    <article class="article" class="blog-post">
      <blockquote>
<p>尾递归与递归的对比，以及在Java与Kotlin中如何运用</p>
</blockquote>
<h3 id="关于尾递归">关于尾递归</h3>
<ul>
<li>尾递归</li>
</ul>
<p>尾递归，比线性递归多一个参数(这个参数是上一次调用函数得到的结果)。关键点在于，尾递归每次调用都在收集结果，避免了线性递归不收集结果只能依次展开消耗内存的坏处。</p>
<p>线性递归创建栈内存累积而后计算收缩，尾递归只会占用恒量的内存(类似迭代)。</p>
<ul>
<li>尾递归优化</li>
</ul>
<p>尾递归优化主要是对栈内存空间的优化,从O(n)到O(1)。对于时间的优化是由于对空间的优化导致内存分配的工作减少所产生的, 是一个常数级别的优化。</p>
<ul>
<li>函数式编程中的递归与迭代</li>
</ul>
<p>在一些函数式编程语言(例如Scala)中是鼓励使用递归，而不是循环来解决问题。这是因为循环会引入中间变量,而函数范式强调的是无副作用，强调函数计算的纯粹性，每个函数的执行都是没有副作用的，
函数所有功能就是返回一个新的值，没有其他行为，尤其是不得修改外部变量的值。</p>
<h3 id="尾递归示例">尾递归示例</h3>
<ul>
<li>递归实现阶乘</li>
</ul>
<pre><code>public static int factorialRecursion(final int number) {
    if (number == 1) return number;
        else return number * factorialRecursion(number - 1);
}

当调用factorialRecursion(5)时 栈的情况:

factorialRecursion(5)
5 * factorialRecursion(4)
5 * (4 * factorialRecursion(3))
5 * (4 * (3 * factorialRecursion(2)))
5 * (4 * (3 * (2 * factorialRecursion(1))))
5 * (4 * (3 * (2 * 1)))
5 * (4 * (3 * 2))
5 * (4 * 6)
5 * 24
120

这里就是典型的线性递归创建栈内存累积而后计算收缩，从左到右，达到顶峰，再从右到左收缩。使用迭代只占据常量栈，使用更新栈而非
扩展栈进行计算，因此迭代相比线性递归使用的内存更少。

为什么会扩展：因为在没有递归到底之前，程序的中间变量会一直保存着，因此每一次递归都需要开辟一个新的栈空间来保存中间变量
</code></pre><ul>
<li>尾递归实现阶乘</li>
</ul>
<pre><code> public static int factorialTailRecursion(final int factorial, final int number) {
        if (number == 1) return factorial;
        else return factorialTailRecursion(factorial * number, number - 1);
}

当调用factorialTailRecursion(1,5)时:

factorialTailRecursion(1, 5)
factorialTailRecursion(5, 4)
factorialTailRecursion(20, 3)
factorialTailRecursion(60, 2)
factorialTailRecursion(120, 1)
120

分析上面递归函数栈累积的原因就是在每次return的时候都会附带一个变量，因此只需要在return的时候不附带这个变量即可。尾递归使用一个参数来保存上一轮递归的结果，把变化的参数传递给递归函数的变量了。

尾递归通过每轮递归结束后刷新当前的栈空间，复用了栈，克服了线性递归栈内存累积而后计算收缩，存在栈溢出风险。

总结尾递归：return后面不附带任何变量的递归写法，递归发生在函数最尾部,我们称之为'尾递归'。
</code></pre><h3 id="尾递归优化-java">尾递归优化-Java</h3>
<p>Tail-Recursion 依赖于编译器对尾递归写法的优化，Javac对Tail-Recursion并没有做特定的优化，使用尾递归的写法，该栈溢出还是栈溢出。</p>
<p>Javac为什么没有Tail-Recursion优化，参考下面的链接,可以得知原因:</p>
<p>因为在JDK许多类中，有许多安全敏感方法依赖于计算JDK库代码和调用代码之间的堆栈帧来确定谁在调用它们。tail-recursion优化会改变堆栈上帧数，会破坏它并导致计算错误。因此JDK开发人员已经取代了这种机制。</p>
<p><a href="https://softwareengineering.stackexchange.com/questions/272061/why-doesnt-java-have-optimization-for-tail-recursion-at-all">https://softwareengineering.stackexchange.com/questions/272061/why-doesnt-java-have-optimization-for-tail-recursion-at-all</a></p>
<ul>
<li>使用Lambda优化尾递归</li>
</ul>
<p>设计一个函数接口代替递归中的栈帧，利用Stream将递归转换为迭代，</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">/**
</span><span style="color:#75715e"> * @Author : lhr
</span><span style="color:#75715e"> * @Date : 11:15 2019/8/3
</span><span style="color:#75715e"> *
</span><span style="color:#75715e"> * 尾递归函数式接口
</span><span style="color:#75715e"> */</span>
<span style="color:#a6e22e">@FunctionalInterface</span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">TailRecursion</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> <span style="color:#f92672">{</span>

    <span style="color:#75715e">/**
</span><span style="color:#75715e">     * 用于递归栈帧之间的连接,惰性求值
</span><span style="color:#75715e">     * @return 下一个递归栈帧
</span><span style="color:#75715e">     */</span>
    TailRecursion<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">apply</span><span style="color:#f92672">();</span>

    <span style="color:#75715e">/**
</span><span style="color:#75715e">     * 判断当前递归是否结束
</span><span style="color:#75715e">     * @return 默认为false,因为正常的递归过程中都还未结束
</span><span style="color:#75715e">     */</span>
    <span style="color:#66d9ef">default</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">isFinished</span><span style="color:#f92672">(){</span>
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#75715e">/**
</span><span style="color:#75715e">     * 获得递归结果,只有在递归结束才能调用,这里默认给出异常,通过工具类的重写来获得值
</span><span style="color:#75715e">     * @return 递归最终结果
</span><span style="color:#75715e">     */</span>
    <span style="color:#66d9ef">default</span> T <span style="color:#a6e22e">getResult</span><span style="color:#f92672">()</span>  <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> Error<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;递归还没有结束,调用获得结果异常!&#34;</span><span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>

    <span style="color:#75715e">/**
</span><span style="color:#75715e">     * 及早求值,执行者一系列的递归,因为栈帧只有一个,所以使用findFirst获得最终的栈帧,接着调用getResult方法获得最终递归值
</span><span style="color:#75715e">     * @return 及早求值,获得最终递归结果
</span><span style="color:#75715e">     */</span>
    <span style="color:#66d9ef">default</span> T <span style="color:#a6e22e">invoke</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> Stream<span style="color:#f92672">.</span><span style="color:#a6e22e">iterate</span><span style="color:#f92672">(</span><span style="color:#66d9ef">this</span><span style="color:#f92672">,</span> TailRecursion<span style="color:#f92672">::</span>apply<span style="color:#f92672">)</span>
                <span style="color:#f92672">.</span><span style="color:#a6e22e">filter</span><span style="color:#f92672">(</span>TailRecursion<span style="color:#f92672">::</span>isFinished<span style="color:#f92672">)</span>
                <span style="color:#f92672">.</span><span style="color:#a6e22e">findFirst</span><span style="color:#f92672">()</span>
                <span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">()</span>
                <span style="color:#f92672">.</span><span style="color:#a6e22e">getResult</span><span style="color:#f92672">();</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>设计一个对外统一的尾递归包装类，目的是达到可以复用的效果，包装递归方法 1怎样调用下次递归,2递归的终止条件</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">/**
</span><span style="color:#75715e"> * @Author : lhr
</span><span style="color:#75715e"> * @Date : 11:59 2019/8/3
</span><span style="color:#75715e"> *
</span><span style="color:#75715e"> * 使用尾递归的类,目的是对外统一方法
</span><span style="color:#75715e"> *
</span><span style="color:#75715e"> * 调用下次递归/结束本轮递归
</span><span style="color:#75715e"> *
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">TailInvoke</span> <span style="color:#f92672">{</span>

    <span style="color:#75715e">/**
</span><span style="color:#75715e">     * 统一结构的方法，获取当前递归的下一个递归
</span><span style="color:#75715e">     * @param nextFrame
</span><span style="color:#75715e">     * @param &lt;T&gt;
</span><span style="color:#75715e">     * @return
</span><span style="color:#75715e">     */</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> TailRecursion<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">call</span><span style="color:#f92672">(</span><span style="color:#66d9ef">final</span> TailRecursion<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> nextFrame<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> nextFrame<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#75715e">/**
</span><span style="color:#75715e">     * 结束当前递归，重写对应的默认方法的值,完成状态改为true,设置最终返回结果,设置非法递归调用
</span><span style="color:#75715e">     *
</span><span style="color:#75715e">     * @param value 最终递归值
</span><span style="color:#75715e">     * @param &lt;T&gt;   T
</span><span style="color:#75715e">     * @return 一个isFinished状态true的尾递归, 外部通过调用接口的invoke方法及早求值, 启动递归求值。
</span><span style="color:#75715e">     */</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> TailRecursion<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">done</span><span style="color:#f92672">(</span>T value<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> TailRecursion<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;()</span> <span style="color:#f92672">{</span>
            <span style="color:#a6e22e">@Override</span>
            <span style="color:#66d9ef">public</span> TailRecursion<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">apply</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
                <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> Error<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;递归已经结束,非法调用apply方法&#34;</span><span style="color:#f92672">);</span>
            <span style="color:#f92672">}</span>

            <span style="color:#a6e22e">@Override</span>
            <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">isFinished</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
                <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
            <span style="color:#f92672">}</span>

            <span style="color:#a6e22e">@Override</span>
            <span style="color:#66d9ef">public</span> T <span style="color:#a6e22e">getResult</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
                <span style="color:#66d9ef">return</span> value<span style="color:#f92672">;</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">};</span>
    <span style="color:#f92672">}</span>

<span style="color:#f92672">}</span>
</code></pre></div><p>lamdba优化尾递归 阶乘计算示例</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">   <span style="color:#75715e">/**
</span><span style="color:#75715e">     * 阶乘计算 -- 使用尾递归接口完成
</span><span style="color:#75715e">     *
</span><span style="color:#75715e">     * @param factorial 当前递归栈的结果值
</span><span style="color:#75715e">     * @param number    下一个递归需要计算的值
</span><span style="color:#75715e">     * @return 尾递归接口, 调用invoke启动及早求值获得结果
</span><span style="color:#75715e">     */</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> TailRecursion<span style="color:#f92672">&lt;</span>Long<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">factorialTailRecursion</span><span style="color:#f92672">(</span><span style="color:#66d9ef">final</span> <span style="color:#66d9ef">long</span> factorial<span style="color:#f92672">,</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> number<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>number <span style="color:#f92672">==</span> 1<span style="color:#f92672">)</span>
            <span style="color:#66d9ef">return</span> TailInvoke<span style="color:#f92672">.</span><span style="color:#a6e22e">done</span><span style="color:#f92672">(</span>factorial<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">else</span>
            <span style="color:#66d9ef">return</span> TailInvoke<span style="color:#f92672">.</span><span style="color:#a6e22e">call</span><span style="color:#f92672">(()</span> <span style="color:#f92672">-&gt;</span> factorialTailRecursion<span style="color:#f92672">(</span>factorial <span style="color:#f92672">+</span> number<span style="color:#f92672">,</span> number <span style="color:#f92672">-</span> 1<span style="color:#f92672">));</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">//调用Invoke启动迭代并获取结果
</span><span style="color:#75715e"></span>        factorialTailRecursion<span style="color:#f92672">(</span>1<span style="color:#f92672">,</span> 10000000<span style="color:#f92672">).</span><span style="color:#a6e22e">invoke</span><span style="color:#f92672">();</span>
    <span style="color:#f92672">}</span>
</code></pre></div><h3 id="尾递归优化-kotlin">尾递归优化-Kotlin</h3>
<ul>
<li>tailrec关键字</li>
</ul>
<p>Kotlin 支持尾递归，这允许一些通常用循环写的算法改用递归函数来写，而无堆栈溢出的风险。 当一个函数用 tailrec 修饰符标记并满足所需的形式时，编译器会优化该递归，留下一个快速而高效的基于循环的版本。</p>
<ul>
<li>尾递归实现阶乘(Kotlin版本)</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">tailrec</span> <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">factorialTailRecursion</span>(factorial: Int, number: Int): Int {
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">if</span> (number == <span style="color:#ae81ff">1</span>) factorial
    <span style="color:#66d9ef">else</span> factorialTailRecursion(factorial * number, number - <span style="color:#ae81ff">1</span>)
}
</code></pre></div><ul>
<li>最终代码(经过Kotlin编译器优化)</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">factorialTailRecursion</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> factorial<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> number<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
      <span style="color:#66d9ef">while</span><span style="color:#f92672">(</span>number <span style="color:#f92672">!=</span> 1<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
         <span style="color:#66d9ef">int</span> var10000 <span style="color:#f92672">=</span> factorial <span style="color:#f92672">*</span> number<span style="color:#f92672">;</span>
         <span style="color:#f92672">--</span>number<span style="color:#f92672">;</span>
         factorial <span style="color:#f92672">=</span> var10000<span style="color:#f92672">;</span>
      <span style="color:#f92672">}</span>

      <span style="color:#66d9ef">return</span> factorial<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div><h3 id="参考">参考</h3>
<p><a href="https://kotlintc.com/articles/4633">https://kotlintc.com/articles/4633</a></p>
<p><a href="https://www.cnblogs.com/invoker-/p/7723420.html">https://www.cnblogs.com/invoker-/p/7723420.html</a></p>


      
        <div class="blog-tags">
          
            <a
              href="https://chinalhr.github.io/tags/%E5%B0%BE%E9%80%92%E5%BD%92/"
              >尾递归</a
            >&nbsp;
          
        </div>
      
    </article>
    
      <script>
  document.addEventListener('scroll', function () {
    if (
      document.body.scrollTop > 50 ||
      document.documentElement.scrollTop > 50
    ) {
      document.getElementById('backtotopButton').style.opacity = '1'
      document.getElementById('backtotopButton').style.transition = '0.5s'
    } else {
      document.getElementById('backtotopButton').style.opacity = '0'
      document.getElementById('backtotopButton').style.transition = '0.5s'
    }
  })

  function topFunction() {
    document.body.scrollTop = 0 
    document.documentElement.scrollTop = 0 
  }
</script>

      <button onclick="topFunction()" id="backtotopButton">
        <em class="fa fa-angle-up"></em>
      </button>
    
    
      

    
  </div>

    <footer>
  

<div class="social-icons">
  
    
    
      
      <a href="https://github.com/chinalhr" name="GitHub">
        <em class="fab fa-github"></em>
      </a>
    
       &nbsp;&ndash;&nbsp;
      <a href="mailto:13435500980@163.com" name="Email">
        <em class="fas fa-envelope"></em>
      </a>
    
  

  
</div>


  
  <div class="container">
    <p class="credits copyright">
      <a href="https://chinalhr.github.io/about">hanrong.li</a>
      &nbsp;&copy;
      2021
      
        &nbsp;/&nbsp;
        <a href="https://chinalhr.github.io/">ChinaLHR Blog</a>
      
      &nbsp;&ndash;&nbsp;
      <em class="fas fa-moon" id="dark-mode-toggle"></em>
    </p>

    <p class="credits theme-by">
      Powered By <a href="https://gohugo.io">Hugo</a>&nbsp;
      Theme
      <a href="https://github.com/matsuyoshi30/harbor">Harbor</a>
    </p>
  </div>
</footer>

  </body>
</html>
