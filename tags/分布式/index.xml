<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>分布式 on LHR</title>
    <link>https://chinalhr.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/</link>
    <description>Recent content in 分布式 on LHR</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 08 Sep 2018 23:02:55 +0800</lastBuildDate>
    
	<atom:link href="https://chinalhr.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>基于SnowFlake的分布式UID生成服务</title>
      <link>https://chinalhr.github.io/post/uidgenerateserver/</link>
      <pubDate>Sat, 08 Sep 2018 23:02:55 +0800</pubDate>
      
      <guid>https://chinalhr.github.io/post/uidgenerateserver/</guid>
      <description>&lt;blockquote&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>分布式锁实现(基于Redis|Zookeeper)</title>
      <link>https://chinalhr.github.io/post/distributedlocks/</link>
      <pubDate>Sun, 15 Jul 2018 18:38:26 +0800</pubDate>
      
      <guid>https://chinalhr.github.io/post/distributedlocks/</guid>
      <description> 学习分布式锁实现
 分布式锁  关于： 当多个进程(集群)不在同一个系统中，用分布式锁控制多个进程对资源的访问 分布式锁对比线程锁：线程锁可以利用共享堆内存标记存储位置达到目的；分布式锁因为进程不在同一台机器上，需要采取对所有进程可见的中间件标记存储位置达到目的 问题：需要考虑锁对所有进程可见，锁与进程间网络问题 实现：基于数据库，缓存，分布式协调中间件(Zookeeper|Chubby)  设计  可以保证在分布式部署的应用集群中，同一个方法在同一时间只能被一台机器上的一个线程执行 设计为可重入锁，避免死锁 阻塞与非阻塞获取锁方式  基于Redis实现  思路  加锁： 使用set命令(key，value，time，NX) 释放锁:使用del(key)  问题  线程a执行时间超过锁wait时间，导致锁自动释放，①线程b获取了锁和线程a并发访问代码块，②线程a执行结束释放了线程b的锁：  ①避免并发问题：给获取锁的线程开启一个守护线程，给快超时的锁增加wait时间 ②避免锁误删：加锁的时候把当前的线程ID当做value，并在删除之前验证key对应的value是不是自己线程的ID(使用lua脚本确保判断和释放锁的原子性)    基于Zookeeper实现</description>
    </item>
    
  </channel>
</rss>