<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us">
<head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="generator" content="Hugo 0.31.1" />

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>函数式接口-Supplier|Predicate|Consumer|Function &middot; LHR</title>

  
  <link rel="stylesheet" href="https://chinalhr.github.io/css/print.css" media="print">
  <link rel="stylesheet" href="https://chinalhr.github.io/css/poole.css">
  <link rel="stylesheet" href="https://chinalhr.github.io/css/syntax.css">
  <link rel="stylesheet" href="https://chinalhr.github.io/css/hyde.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700">

  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/favicon.png">

  
  <link href="" rel="alternate" type="application/rss+xml" title="LHR" />
</head>

  <body class="theme-base-0d ">
  <div class="sidebar">
  <div class="container">
    <div class="sidebar-about">
      <a href="https://chinalhr.github.io/"><h1>LHR</h1></a>
      <p class="lead">
       Read the fucking source code 
      </p>
    </div>

    <ul class="sidebar-nav">
      <li><a href="https://chinalhr.github.io/">Home</a> </li>
      <li><a href="/post/about/"> About </a></li><li><a href="/tags/catalogue/"> Catalogue </a></li>
    </ul>

    <p>&copy; 2018. All rights reserved. </p>
  </div>
</div>

    <div class="content container">
    <div class="post">
  <h1>函数式接口-Supplier|Predicate|Consumer|Function</h1>
  <span class="post-date">Wed, Jul 11, 2018</span>
  <p></p>

<h2 id="supplier">Supplier</h2>

<ul>
<li>Supplier<T>接口没有入参，通过调用T get()返回一个T类型的对象</li>
<li>开发中通过supplier实时获取配置(配置使用json写在数据库中)</li>
</ul>

<pre><code>    //设置Supplier获取函数为从数据库获取
    zSetRedisConsumer.setBatchProcessSize(() -&gt; hkConfigService.findRedisBuffConfig().getBatchProcessSize());

    private Supplier&lt;Long&gt; fixDelayMilliseconds;
    @Override
    public RedisConsumer setFixDelayMilliseconds(Supplier&lt;Long&gt; fixDelayMilliseconds) {
        this.fixDelayMilliseconds = fixDelayMilliseconds;
        return this;
    }
    //通过调用batchProcessSize.get()实时获取配置

</code></pre>

<h2 id="predicate">Predicate</h2>

<ul>
<li>Predicate函数式接口的主要作用就是提供一个boolean test(T t)方法(断言)，接受一个参数返回一个布尔类型</li>
<li>开发中使用Predicate进行StreamFilter</li>
</ul>

<pre><code>public class PredicateDemo {
    public static void main(String[] args) {
        List&lt;Integer&gt; list = Arrays.asList(...);
        PredicateTest predicateTest = new PredicateTest();
        //输出大于5的数字
        List&lt;Integer&gt; result = predicateTest.conditionFilter(list, integer -&gt; integer &gt; 5);
        result.forEach(System.out::println);
    }
    //抽象方法
    public List&lt;Integer&gt; conditionFilter(List&lt;Integer&gt; list, Predicate&lt;Integer&gt; predicate){
        return list.stream().filter(predicate).collect(Collectors.toList());
    }
}
</code></pre>

<h2 id="consumer">Consumer</h2>

<ul>
<li>Consumer函数式接口的主要作用就是提供一个void accept(T t)方法(进行消费)，执行带有副作用的操作。forEach源码使用的Consumer接口。</li>
</ul>

<pre><code>Consumer&lt;String&gt; printString = s -&gt; System.out.println(s);
        printString.accept(&quot;helloWorld!&quot;);
        //控制台输出 helloWorld!
</code></pre>

<h2 id="function">Function</h2>

<ul>
<li>Function函数式接口主要作用是提供一个R apply(T t)方法(进行计算并返回结果)。
<code>
System.out.println(validInput(name, inputStr -&gt; inputStr.isEmpty() ? &quot;名字不能为空&quot;:inputStr));
System.out.println(validInput(name1, inputStr -&gt; inputStr.length() &gt; 3 ? &quot;名字过长&quot;:inputStr));
//抽象方法
public static String validInput(String name,Function&lt;String,String&gt; function) {
    return function.apply(name);
}
</code></li>
</ul>
</div>


    </div>

    
  </body>
</html>