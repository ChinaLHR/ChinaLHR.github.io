<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Redis on LHR</title>
    <link>https://chinalhr.github.io/tags/redis/</link>
    <description>Recent content in Redis on LHR</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 10 Jul 2018 22:01:41 +0800</lastBuildDate>
    
	<atom:link href="https://chinalhr.github.io/tags/redis/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>消息队列QPS优化(使用Redis做MQ的Buff)</title>
      <link>https://chinalhr.github.io/post/redisdomqbuff/</link>
      <pubDate>Tue, 10 Jul 2018 22:01:41 +0800</pubDate>
      
      <guid>https://chinalhr.github.io/post/redisdomqbuff/</guid>
      <description>设计  场景：每次用户消费，api模块发送MQ消息(变更账户信息)到Bill模块，进行elasticsearch的索引更新。 问题：api模块由于引入了大量的mq消息的发送,导致mq的qps过高，带来的性能隐患。 解决：采用Redis作为MQ的缓存中间层与合并MQ消息，使用Task定时读取缓存发送MQ消息，将MQ的发送压力从api模块迁移到 task模块中。  Redis存储结构  使用zSet结构，value为订单id，score为创建时间 优点：  ①基于时间排序，实现先进先出的数据结构(伪队列) ②使用Set可以合并多个订单修改的消息，达到合并消息，节省资源，优化速度的目的    流程 原本api模块需要发送账单MQ消息时，将账单id存入Redis，task模块定时(ScheduledExecutorService)从redis中取出账单信息，进行MQ消息发送。
细节  task调度Scheduled的时间估算 task模块异步执行MQ线程池参数估算https://www.zhihu.com/question/38128980 分布式环境下的避免Poll竞争：  使用分布式锁(基于Redis|Zookeeper)避免不同的机器消费相同的zSet  根据业务估算ZSet的批处理数量，使用Redis事务保证一致性 补偿机制：定时对超时任务进行处理  简单流程图 Jmeter进行性能测试</description>
    </item>
    
  </channel>
</rss>