<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us">
<head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="generator" content="Hugo 0.31.1" />

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>Spring Aop &middot; LHR</title>

  
  <link rel="stylesheet" href="https://chinalhr.github.io/css/print.css" media="print">
  <link rel="stylesheet" href="https://chinalhr.github.io/css/poole.css">
  <link rel="stylesheet" href="https://chinalhr.github.io/css/syntax.css">
  <link rel="stylesheet" href="https://chinalhr.github.io/css/hyde.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700">

  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/favicon.png">

  
  <link href="" rel="alternate" type="application/rss+xml" title="LHR" />
</head>

  <body class="theme-base-0d ">
  <div class="sidebar">
  <div class="container">
    <div class="sidebar-about">
      <a href="https://chinalhr.github.io/"><h1>LHR</h1></a>
      <p class="lead">
       Read the fucking source code 
      </p>
    </div>

    <ul class="sidebar-nav">
      <li><a href="https://chinalhr.github.io/">Home</a> </li>
      <li><a href="/post/about/"> About </a></li><li><a href="/tags/catalogue/"> Catalogue </a></li>
    </ul>

    <p>&copy; 2018. All rights reserved. </p>
  </div>
</div>

    <div class="content container">
    <div class="post">
  <h1>Spring Aop</h1>
  <span class="post-date">Mon, Sep 24, 2018</span>
  <p></p>

<h2 id="joinpoint-连接点">Joinpoint（连接点）</h2>

<p>连接点是指那些被拦截到的点。在 Spring 中,这些点指的是方法,因为 Spring 只支持方法类型的连接点。</p>

<h2 id="pointcut-切入点">Pointcut(切入点)</h2>

<p>所谓切入点是指我们要对哪些 Joinpoint 进行拦截的定义。
PointCut 依赖了ClassFilter和MethodMatcher,ClassFilter用来指定特定的类，MethodMatcher 指定特定的函数,能实现函数级别的AOP。</p>

<p><img src="https://images.gitee.com/uploads/images/2018/0924/144733_8f895b8d_558165.png" alt="输入图片说明" title="屏幕截图.png" /></p>

<ul>
<li>MethodMatcher 两个实现类

<ul>
<li>StaticMethodMatcher：不在运行时检测参数</li>
<li>DynamicMethodMatcher：DynamicMethodMatcher要在运行时实时检测参数</li>
</ul></li>
</ul>

<h2 id="advice-通知-增强">Advice（通知/增强）</h2>

<p>通知是指拦截到 Joinpoint 之后所要做的事情就是通知。通知分为【前置通知】, 【后置通知】,【异常通知】,【最终通知】, 【环绕通知】(切面要完成的功能)
* per-class类型的Advice（可以在目标对象类的所有实例之间共享，通常只提供方法拦截功能，不会对目标对象保存任何状态或添加新功能）</p>

<p><img src="https://images.gitee.com/uploads/images/2018/0924/151710_ec13557c_558165.png" alt="输入图片说明" title="屏幕截图.png" /></p>

<ul>
<li>per-instance类型的Advice（不会在目标类所有实例之间共享，而是会为不同的实例对象保存他们各自的状态以及相关逻辑）Introduction可以在不改变目标类的定义的情况下，为对象添加新的属性与行为</li>
</ul>

<p><img src="https://images.gitee.com/uploads/images/2018/0924/151806_7d018003_558165.png" alt="输入图片说明" title="屏幕截图.png" /></p>

<h2 id="advisor-aspect-切面">Advisor/Aspect(切面)</h2>

<p>Advisor/Aspect是切入点和通知（引介）的结合。
* Spring AOP的PointcutAdvisor
AbstractPointcutAdvisor 实现了Ordered,为多个Advice指定顺序，顺序为Int类型，越小优先级越高,
AbstractGenericPointcutAdvisor 指定了Advice，除了Introduction之外的类型
<img src="https://images.gitee.com/uploads/images/2018/0924/152514_4b962f2b_558165.png" alt="输入图片说明" title="屏幕截图.png" /></p>

<h2 id="proxy-代理">Proxy(代理)</h2>

<p>一个类被 AOP 织入增强后，就产生一个结果代理类。
<img src="https://images.gitee.com/uploads/images/2018/0924/152829_e6fb6706_558165.png" alt="输入图片说明" title="屏幕截图.png" />
* ProxyConfig</p>

<pre><code>private boolean proxyTargetClass = false;//true,使用CGLIB,false,使用原生

private boolean optimize = false;//是否进行优化

boolean opaque = false;//是否强制转化为advised

boolean exposeProxy = false;//AOP生成对象时，绑定到ThreadLocal, 可以通过AopContext获取

private boolean frozen = false;//代理信息一旦设置，是否允许改变
</code></pre>

<ul>
<li>ProxyFactory
ProxyFactory是Spring的AOP织入器，接受Pointcut/Advice返回织入了横切逻辑的目标对象代理。</li>
<li>ProxyFactoryBean
本质上是一个用来生产Proxy的FactoryBean，AOP与IOC的融合。
（如果容器中某个对象依赖于ProxyFactoryBean ，他将会使用到ProxyFactoryBean的getObject()方法返回的内容）</li>
</ul>

<h2 id="aop核心实现">aop核心实现</h2>

<p>将AOP融入Bean的创建过程,AspectJ方式织入的核心，是一个BeanPostProcess（会扫描所有的Pointcut并对Bean进行织入）</p>

<pre><code>public class AspectJAwareAdvisorAutoProxyCreator implements BeanPostProcessor, BeanFactoryAware {

	private AbstractBeanFactory beanFactory;

	@Override
	public Object postProcessBeforeInitialization(Object bean, String beanName) throws Exception {
		return bean;
	}


	//在Bean创建之后对Bean进行AOP处理
	@Override
	public Object postProcessAfterInitialization(Object bean, String beanName) throws Exception {
	if (bean instanceof AspectJExpressionPointcutAdvisor) {
			return bean;
	}
    if (bean instanceof MethodInterceptor) {
            return bean;
    }

    //获取所有Pointcut，进行切面处理，返回完成Aop的Proxy
List&lt;AspectJExpressionPointcutAdvisor&gt; advisors = beanFactory
				.getBeansForType(AspectJExpressionPointcutAdvisor.class);
for (AspectJExpressionPointcutAdvisor advisor : advisors) {
	if (advisor.getPointcut().getClassFilter().matches(bean.getClass())) {
	// 1. 设置被代理对象(Joinpoint)
	AdvisedSupport advisedSupport = new AdvisedSupport();
	TargetSource targetSource = new TargetSource(bean, bean.getClass().getInterfaces());
	advisedSupport.setTargetSource(targetSource);
	// 2. 设置拦截器(Advice)
	advisedSupport.setMethodInterceptor((MethodInterceptor) advisor.getAdvice());
	advisedSupport.setMethodMatcher(advisor.getPointcut().getMethodMatcher());
	// 3. 创建代理(Proxy)
	return new JdkDynamicAopProxy(advisedSupport).getProxy();
			}
		}
		return bean;
	}
	@Override
	public void setBeanFactory(BeanFactory beanFactory) throws Exception {
		this.beanFactory = (AbstractBeanFactory) beanFactory;
	}
}

</code></pre>
</div>


    </div>

    
  </body>
</html>